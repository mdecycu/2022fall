<h1>About</h1>
<p>網站: <a href="https://mde.tw/2022fall">https://mde.tw/2022fall</a> </p>
<p>倉儲: <a href="https://github.com/mdecycu/2022fall">https://github.com/mdecycu/2022fall</a> </p>
<p>本網站主要統整 2022 Fall <a href="https://mde.tw/content/cp2022">計算機程式</a>以及<a href="https://mde.tw/content/cad2022">電腦輔助設計與實習</a>課程的相關內容、議題與對策.</p>
<p>2022 Fall 最終版的 Python 可攜程式系統為 <a href="https://nfuedu.sharepoint.com/:u:/s/cad2022/EXABheFswCtEtT5p-9uDN4ABuK3DASC8mKkFzpLA3q7f6g?e=V2ZBNw">portable_python_w10_nx_robodk.7z</a> (1.03 GB, 必須登入 @nfu OneDrive 帳號後才能下載), 這是在課程第十週釋出的版本, 由於必須配合 NX2027 所採用的 NXOpen for Python API 程式解譯需求, 除了 Python 3.10.6 版之外, 還額外提供 Python 3.8.10 的解譯器版本, 以及 <a href="https://robodk.com/download">RoboDK 5.5</a> 可攜系統.</p>
<p>相關課程:</p>
<p style="padding-left: 30px;">網際內容管理 <a href="https://mde.tw/wcm2023">https://mde.tw/wcm2023</a> </p>
<p style="padding-left: 30px;">協同產品設計實習 <a href="https://mde.tw/cd2023">https://mde.tw/cd2023</a> </p><h2>networking</h2>
<p>IPv4 與 IPv6 是兩種不同架構的網路協定, 由於 IPv4 網路協定已經不敷目前網路應用所需, 因此衍生出 IPv6 網路協定. 但由於 IPv4 網路協定已經使用超過 40 年, 因此仍會存在很長一段時間. 在可見的未來, IPv4 與 IPv6 網路協定將會同時存在.</p>
<p>在 Windows 操作系統可在命令列以 ipconfig /all 取的與 internet protocol configuration 有關的資訊.</p>
<p>若電腦環境只提供 IPv4 網路協定, 但需要透過特定網路協定 (包括 http(s), ssh, sftp 等協定) 與只支援 IPv6 網路協定的網站進行資料交換, 就必須設定能夠提供雙網路 (IPv4 與 IPv6) 協定的代理主機 (Proxy server).</p>
<p>http(s):</p>
<p style="padding-left: 30px;">在 Windows 操作系統下, Edge 與 Chrome 只能使用操作系統設定的代理主機, 而 Firefox 與 Waterfox 則可以使用操作系統的代理主機設定, 或者自行設定連線的代理主機.</p>
<p>ssh (sftp):</p>
<p style="padding-left: 30px;">在 Windows 操作系統下的 ssh 網路協定, 可以利用 putty 進行設定, 並以 session 名稱代表 putty 中與 proxy 及 Auth (認證) 有關的設定. putty 中的 puttygen.exe 可以建立 OpenSSH 格式的 public key, 以及 putty 格式的 private key. 為了在近端連線到 Github, OpenSSH 格式的 public key 必須送到 Github 帳號下 Settings 的 SSH and GPG keys 區. 而 putty 中有關 session 的設定則會被存入以下登錄區:</p>
<p style="padding-left: 60px;">電腦\HKEY_CURRENT_USER\SOFTWARE\SimonTatham\PuTTY</p>
<p style="padding-left: 30px;">另外, 在 Windows 操作系統希望採用 putty 設定 git 連線用的 ssh, 必須在啟動可攜系統時, 宣告:</p>
<p style="padding-left: 60px;">set GIT_SSH=%cd%\putty\plink.exe</p>
<p style="padding-left: 30px;">在 Linux 操作系統下的 ssh 網路協定, 可以利用 ssh-keygen 建立, 內定的 keys 將會存入使用者工作目錄下的 .ssh 目錄, 且以 id_rsa 與 id_rsa.pub 代表其 private key 與 public key. 至於 Linux 環境下的 ssh proxy 設定, 則位於 .ssh/config 檔案中, config 的設定格式為:</p>
<p style="padding-left: 60px;">Host demo</p>
<p style="padding-left: 60px;">User git</p>
<p style="padding-left: 60px;">Hostname github.com</p>
<p style="padding-left: 60px;">ProxyCommand /usr/bin/ncat --proxy p4.cycu.org:3128 --proxy-type http %h %p</p><h2>cmsimde</h2>
<p><a href="https://github.com/mdecycu/cmsimde">https://github.com/mdecycu/cmsimde</a> 是一套利用 Python + <span style="color: #ff0000;">Flask</span> 建立的網際內容管理系統.</p>
<p>了解 cmsimde 的設計理念與架構, 將有助於有效運用這一套系統.</p>
<p>cmsimde 主要讓使用者可以利用 <span style="color: #ff0000;">Github</span> 倉儲建立靜態網站, 並可在近端與 Windows 或 Linux 操作系統上建立動態網站.</p>
<p>所謂靜態網站指的是一個 WWW 全球資訊網伺服器, 只負責伺服 html 網頁、 <span style="color: #ff0000;">Javascript</span> 程式以及相關檔案.</p>
<p>之所以稱為靜態, 是指此網頁除了透過在客戶端 (瀏覽器) 上執行的 Javascript 程式外, 無伺服器上的程式可直接改變網站內容, 且網站上沒有讓使用者 login 的機制.</p>
<p>相較之下, 所謂動態網站, 則指具備 login 機制, 使用者登入網際內容管理系統後, 可以直接更動網站內容.</p>
<p>利用 cmsimde 建立的動態網站可以轉為靜態網站內容. </p>
<p>能夠執行 cmsimde 動態網站的 Python 需要安裝下列模組:</p>
<p><span>flask flask_cors bs4 lxml pelican markdown pyopenssl</span></p>
<p><span>而在近端為了管理 cmsimde 中的網際簡報與網誌, 通常建議再加裝 leo 模組, 因此希望執行 cmsimde 動態網站的 Python 環境, 需要以 pip 安裝所需模組:</span></p>
<p style="padding-left: 30px;"><span><span style="color: #ff0000;">pip install flask flask_cors bs4 lxml pelican markdown leo pyopenssl</span> </span></p><h2>Leo Editor</h2>
<p>Leo Editor 可以利用以下程式 recursively import 原始程式 (放入 body panel 後 按 Ctrl + b 執行):</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">'''Recursively import all python files in a directory and clean the result.'''
c.recursiveImport(
    dir_ = r'./',
    kind = '@clean', # The new best practice.
    safe_at_file = False,
    theTypes = None, # Same as ['.py']
)</pre>
<p></p><h1>Git</h1>
<p>Git 是在 2005 年為了有效管理 Linux 操作系統的原始碼而建立. 具有分散式版次管理的特性, 在多人協同開發程式碼的過程, 可以清楚看出各程式段由誰貢獻, 且其分支架構可以讓使用者切出不會影響主分支的版本進行改版, 一旦主分支之外的版本完成後, 可以選擇將改版功能合併至主分支或保留紀錄.</p>
<p>在可攜程式環境中所提供的 git.exe 指令程式來自 <a href="https://git-scm.com/download/win">Git - Downloading Package (git-scm.com)</a> 中的 portablegit.</p><h2>Github</h2>
<h3>Pages</h3>
<h3>Classroom</h3><h3>QandA</h3>
<h4>使用 Github 免費帳號, 有單一檔案容量大小的限制, 若在近端改版時帶有無法 push 至 Github 倉儲的大容量檔案, 該如何處理?</h4>
<div>
<div>Github 有關改版檔案大小限制的說明:</div>
<div></div>
<div style="padding-left: 30px;"><a href="https://docs.github.com/en/repositories/working-with-files/managing-large-files/about-large-files-on-github">About large files on GitHub - GitHub Docs</a></div>
<div style="padding-left: 30px;"></div>
<div style="padding-left: 30px;">GitHub limits the size of files you can track in regular Git repositories.</div>
<div style="padding-left: 30px;"></div>
<div style="padding-left: 30px;">If you attempt to add or update a file that is larger than 50 MB, you will receive a warning from Git. The changes will still successfully push to your repository, but you can consider removing the commit to minimize performance impact.</div>
<div style="padding-left: 30px;"></div>
<div style="padding-left: 30px;">改版提交單一檔案容量大小限制為 <span style="color: #ff0000;">50 MB</span>. 但是若提交單一檔案 50 MB 時, 將會影響工作效率.</div>
<div style="padding-left: 30px;"></div>
<div style="padding-left: 30px;">至於利用瀏覽器, 將檔案上傳至 Github 倉儲的單一檔案容量限制則為 <span style="color: #ff0000;">25 MB</span>.</div>
<div style="padding-left: 30px;"></div>
<div style="padding-left: 30px;">Github 針對<span style="color: #ff0000;">已經新增提交</span>單一檔案超過 50 MB 的處理<a href="https://docs.github.com/en/repositories/working-with-files/managing-large-files/about-large-files-on-github#removing-files-from-a-repositorys-history">如下</a>:</div>
<div style="padding-left: 30px;"></div>
<div style="padding-left: 60px;">在命令列執行指令, 刪除超過容量的大檔案, 若檔案名稱為 big_file.mp4</div>
<div style="padding-left: 60px;"></div>
<div style="padding-left: 90px;">git rm --cached big_file.mp4</div>
<div style="padding-left: 60px;"></div>
<div style="padding-left: 60px;">接著執行下列指令進行訂正 (amend):</div>
<div style="padding-left: 60px;"></div>
<div style="padding-left: 90px;">git commit --amend -CHEAD</div>
<div style="padding-left: 60px;"></div>
<div style="padding-left: 60px;">然後再將訂正後的版本推送到 Github:</div>
<div style="padding-left: 60px;"></div>
<div style="padding-left: 90px;">git push</div>
<div style="padding-left: 30px;"></div>
<div>其他可行的處理方式, 請參考 <a href="https://mde.tw/demo/content/Windows.html" rel="noreferrer noopener" tabindex="-1" target="_blank" title="https://mde.tw/demo/content/windows.html">https://mde.tw/demo/content/Windows.html</a> , 看看你是哪種情況:</div>
<ol>
<li>近端改版尚未提交, 僅對某些檔案進行變更, 但希望刪除這些變更: git checkout . (表示將近端檔案與遠端保持同步).</li>
<li>近端改版已經提交但尚未推送, 希望刪除這些變更: git reset --soft HEAD~, 或者再加上希望刪除的前幾次變更數字.</li>
<li>近端改版已經推送, 但希望刪除這些提交推送的改版內容: git revert 版次號 --no-edit</li>
</ol>
</div><h2>repo</h2><h3>localhost</h3>
<p>在近端(也就是使用者工作的電腦)維護 Github 的倉儲, 有兩種認證方法, 可採用 SSH 認證, 或者採用 Github Token 認證. 而認證的目的是讓擁有 Github 倉儲維護權限的用戶, 可以將近端的改版內容推到 Github 雲端儲存.</p>
<p>採用 Github Token 認證:</p>
<p style="padding-left: 30px;"></p><h3>Replit</h3>
<h3>Stud</h3>
<h1>Python</h1>
<p>Python 是一種解譯式程式語言, 使用者編寫程式碼後, 可以直接執行, 從使用者要求 Python 程式執行時, 解譯器 (Interpreter) 會即時將原始碼轉為 Byte code, 然後根據所在操作系統的二位元檔案格式轉為可以執行的格式後執行.</p>
<p>與解譯式程式語言相對的是編譯式程式語言, 例如: C/C++ 或 Rust 等. 編譯器稱為 Compiler, 當使用者完成 C 或 C++ 程式開發後, 通常需要進行編譯 (Compile) 與連結 (Link) 等過程, 才能得到可以執行的命令檔案.</p>
<p>最早出現的 Python 解譯器, 是採用 C 程式語言編寫的, 稱為 CPython. 此外也有採用 Python 編寫的 Python 解譯器, 稱為 <a href="https://www.pypy.org/">Pypy</a>. 也又用 Java 編寫的 Python 解譯器, 稱為 <a href="https://www.jython.org/">Jython</a>. 以及採用 .NET 技術編寫的 <a href="https://ironpython.net/">IronPython</a>.</p>
<p>至於利用 Javascript 編寫的 Python 解譯器, 其中一種稱為 <a href="https://brython.info/">Brython</a>.</p>
<p>Brython 的執行機制是讓使用者在網頁中導入以 Javascript 編寫的 Python 解譯器程式庫之後, 再將使用者寫在網頁超文件 &lt;script type="text/python"&gt;&lt;/script&gt; 標註中的 Python 程式碼轉為 Javascript 後執行.</p>
<p><span style="color: #ff0000;">Brython 是一種網頁前端的 Python 程式語言</span>, 由於 Brython 程式碼的執行需要在客戶端的瀏覽器, 將伺服器中的 Brython 解譯器下載至客戶端, 之後下載伺服器上所要執行的 Brython 程式原始碼之後, 才能利用瀏覽器中的 Javascript 解譯器進行轉檔後執行, 因此:</p>
<p><span style="color: #ff0000;">Brython 並沒有 CPython 眾多的各式程式庫檔案</span>, 而比較適合如 Javascript 解譯器一樣, 讓網站開發者將輕巧的 Brython 程式碼放在網頁中, 並設法與位於伺服器中的其他 CPython 程式結合使用. 以便達到較少延遲的網頁互動反應效能.</p>
<p>Brython 在網站前端, 加上伺服器後端的 CPython 結合應用機制, 就如同 <a href="https://nodejs.org/en/">Node.js</a> 或 <a href="https://deno.land/">Deno</a> 網站程式開發機制.</p><h2>Brython</h2>
<p>cmsite: wcms use <a href="https://github.com/mdecycu/cmsimde">https://github.com/mdecycu/cmsimde</a> as submodule</p>
<p><a href="https://en.wikipedia.org/wiki/Python_(programming_language)">https://en.wikipedia.org/wiki/Python_(programming_language)</a></p>
<h4>Examples:</h4>
<p style="padding-left: 30px;"><a href="https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d">https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d</a></p>
<p style="padding-left: 30px;"><a href="https://www.geeksforgeeks.org/python-programming-examples/">https://www.geeksforgeeks.org/python-programming-examples/</a></p>
<p style="padding-left: 30px;"><a href="https://www.programiz.com/python-programming/examples">https://www.programiz.com/python-programming/examples</a></p>
<p style="padding-left: 30px;"><a href="https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/">https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/</a></p>
<h4>Python Tutorial:</h4>
<p style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/">https://docs.python.org/3/tutorial/</a></p>
<p style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/introduction.html">An informal introduction to Python</a></p>
<h4>Indentation</h4>
<h4>Variables</h4>
<h4>Comments</h4>
<h4><a href="https://docs.python.org/3/tutorial/introduction.html#numbers">Numbers</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/introduction.html#strings">Strings</a></h4>
<h4>print</h4>
<p><a href="https://docs.python.org/3/tutorial/controlflow.html">Python control flow tools</a></p>
<h4 style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/controlflow.html#for-statements">for</a></h4>
<h4 style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/controlflow.html#if-statements">if</a></h4>
<h4 style="padding-left: 30px;"><a href="https://docs.python.org/3/tutorial/controlflow.html#the-range-function">range</a></h4>
<h4>open</h4>
<h4>read</h4>
<h4><a href="https://docs.python.org/3/tutorial/introduction.html#lists">lists</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences">tuples</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries">dictionaries</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/controlflow.html#defining-functions">functions</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/errors.html#exceptions">try ... except</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops">break</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/controlflow.html#pass-statements">pass</a></h4>
<h4><a href="https://docs.python.org/3/tutorial/classes.html?highlight=classes">classes</a></h4>
<p>這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 (<a href="/downloads/practice_html.txt">practice_html.txt</a> 動態頁面超文件).</p>
<p><a href="/downloads/practice_html.txt">practice_html.txt</a> 動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用.</p>
<p>亦即將所有對應的 html 也使用 Brython 產生, 然後寫為 <a href="https://docs.python.org/3/tutorial/classes.html">class</a> 後, 在範例導入時透過 <a href="https://docs.python.org/3/tutorial/classes.html#instance-objects">instance</a> 引用.</p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">&lt;!-- 啟動 Brython --&gt;
&lt;script&gt;
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
&lt;/script&gt;</pre>
<p>從 1 累加到 100:</p>
<p><button id="add1to100">1 add to 100</button></p>
<p>將 iterable 與 iterator <a href="https://home.gamer.com.tw/creationDetail.php?sn=4337438">相關說明</a>, 利用 Brython 與 Ace Editor 整理在這個頁面.</p>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
</p>
<p><!-- add 1 to 100 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "add1to100" 的按鈕點按時, 執行 add 方法
doc["add1to100"].bind('click', add)
</script>
</p>
<p><!-- add 1 to 100 結束--></p>
<!-- editor1 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"></div>
<!-- editor1 結束 --><hr/><!-- ########################################## -->
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button><button id="cango_three_gears">cango_three_gears</button><button id="bsnake">BSnake</button><button id="aitetris">AI Tetris</button></p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()
Ace3 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run2():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src2"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace3.editor.setValue(prog)
    Ace3.editor.scrollToRow(0)
    Ace3.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace3.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run2'].bind('click', Ace3.run)
doc['kw_show_console2'].bind('click', Ace3.show_console)
doc['kw_clear_console2'].bind('click', Ace3.clear_console)
doc['clear_bd2'].bind('click', clear_bd2)
# 呼叫函式執行
run2()
</script>
</p>
<p><!-- add 1 to 100 part2 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace4 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )

# 透過 Ace4 以類別建立一個通用的 button2, 可以在多個案例中將 gist 程導入編輯區

class button2:
    def __init__(self, url):
        self.url = url

    # 記得加入 event 輸入變數
    def do(self,ev):
        Ace4.editor.setValue(open(self.url).read())
        Ace4.editor.scrollToRow(0)
        Ace4.editor.gotoLine(0)
        Ace4.run()

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add2(ev):
    Ace4.editor.setValue(add_src)
    Ace4.editor.scrollToRow(0)
    Ace4.editor.gotoLine(0)
    Ace4.run()

# id 為 "add1to100part2" 的按鈕點按時, 執行 add 方法
doc["add1to100part2"].bind('click', add2)
# 以下為運用 button2 class 的通用 gist 程式導入區
################################## cango_three_gears start
cango_three_gears_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/cango_three_gears_brython_div2.py"
cango_three_gears = button2(cango_three_gears_url)
doc["cango_three_gears"].bind("click", cango_three_gears.do)
################################## cango_three_gears end
################################## bsnake start
bsnake_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/kmol_snakey.py"
bsnake = button2(bsnake_url)
doc["bsnake"].bind("click", bsnake.do)
################################## bsnake end
################################## aitetris start
aitetris_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/pygame_to_brython_tetris_ai.py"
aitetris = button2(aitetris_url)
doc["aitetris"].bind("click", aitetris.do)
################################## aitetris end
</script>
</p>
<p><!-- add 1 to 100 part2 結束--></p>
<!-- editor2 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename2" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src2', 'kw_filename2');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run2">Run</button> <button id="kw_show_console2">Output</button> <button id="kw_clear_console2">清除輸出區</button><button id="clear_bd2">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console2"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div2"></div>
<!-- editor2 結束 --><hr/>
<h2>cp</h2>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p>Computer Programming 計算機程式</p>
<p>以 Python 程式語言學習計算機程式需要會甚麼?</p>
<p><span style="color: #ff0000;">變數宣告</span></p>
<p>變數訂定規則</p>
<ol>
<li>不可使用 Python 關鍵字作為變數</li>
<li>只能以英文大小寫或 _ (底線) 作為變數開頭</li>
<li>變數名稱分別英文大寫與小寫</li>
</ol>
<p>Python 程式語言的關鍵字:</p>
<div id="keyword"></div>
<script type="text/python">
from browser import document, html
keyword_pos = document["keyword"]
import keyword
for i in keyword.kwlist:
    keyword_pos <= i
    keyword_pos <= ", "
keyword_pos <= "共有 " + str(len(keyword.kwlist)) + " 個."
</script>
<p>變數宣告範例:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 使用 temp 作為變數名稱, 並與整數 30 對應
temp = 30
# 這時印出 temp 的對應值, 就會是 30
print(temp)

# for 迴圈所使用的 index 變數 i 無需在迴圈之前進行宣告.
# 以下程式會印出 0, 1, 2, 3,4 等五個整數.
for i in range(5):
    print(i)</pre>
<p><span style="color: #ff0000;">資料型別轉換</span></p>
<p>int(in) 可以將輸入的 in 變數轉為整數 (integer)</p>
<p>float(in) 可以將輸入的 in 變數轉為浮點數 (floating number)</p>
<p>str(in) 可以將輸入的 in 變數轉為字串 (string)</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 變數 a 與 1 對應
a = 1
# 若要讓 a 的對應值與其他字串相加, 則 a 必須從整數轉為字串
# 整數可以利用 str() 轉為字串
print("a 的對應值為:"  + str(a))</pre>
<p>上面整數轉字串程式執行結果:</p>
<div id="int_to_str"></div>
<script type="text/python">
from browser import document, html
int_to_str_pos = document["int_to_str"]
a = 1
int_to_str_pos <= "a 的對應值為:"  + str(a)
int_to_str_pos <= html.BR()
</script>
<p><span style="color: #ff0000;">資料的基本運算</span></p>
<p>資料包含 integer, floating number 與 string</p>
<p>整數與浮點數可以進行加、減、乘與除運算.</p>
<p>字串則可進行加與乘運算.</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 以下可以利用 for 重複迴圈進行整數累加
# 先設定累加總和變數為 sum
# 一開始尚未進行整數累加, sum 的對應值為 0
sum = 0
# 接著利用 for 迴圈以特定增量值產生希望進入累加的整數
for i in range(1, 10):
    # 假設從 1 要累加到 9, 則上列迴圈可以將增量後的整數對應到 i 變數
    sum = sum + i
    # 當迴圈逐一產生增量後的 i 整數後, 分別與當時的 sum 對應值累加
# 當 i 增加到 9 時, 程式的執行就會跳出 for 環圈, 這時就可以印出累加後的總整數值
print("從 1 累加到 9 總數值為: " + str(sum))</pre>
<p>以上累加程式執行結果:</p>
<div id="add_to_9"></div>
<script type="text/python">
from browser import document, html
# 以下可以利用 for 重複迴圈進行整數累加
# 先設定累加總和變數為 sum
# 一開始尚未進行整數累加, sum 的對應值為 0
sum = 0
# 接著利用 for 迴圈以特定增量值產生希望進入累加的整數
for i in range(1, 10):
    # 假設從 1 要累加到 9, 則上列迴圈可以將增量後的整數對應到 i 變數
    sum = sum + i
    # 當迴圈逐一產生增量後的 i 整數後, 分別與當時的 sum 對應值累加
# 當 i 增加到 9 時, 程式的執行就會跳出 for 環圈, 這時就可以印出累加後的總整數值
add_to_9_pos = document["add_to_9"]
add_to_9_pos <= "從 1 累加到 9 總數值為: " + str(sum)
add_to_9_pos <= html.BR()
</script>
<p><span style="color: #ff0000;">函式定義與呼叫</span></p>
<p>def 為 define 的縮寫, 在 Python 程式語法, 可以利用 def 定義函式.</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 將累加程式寫為函式, start 輸入變數為累加起始整數, 然後增量 1 累加至 end 整數
def int_add(start, end):
    sum = 0
    for i in range(start, end+1):
        sum = sum + i
    return "從 " + str(start) + " 累加到 " + str(end) + " 總數值為: " + str(sum)

int_add(1, 9)</pre>
<p>上列累加函式定義與呼叫執行結果為:</p>
<div id="add_to"></div>
<script type="text/python">
from browser import document, html
# 將累加程式寫為函式, start 輸入變數為累加起始整數, 然後增量 1 累加至 end 整數
def int_add(start, end):
    sum = 0
    for i in range(start, end+1):
        sum = sum + i
    return "從 " + str(start) + " 累加到 " + str(end) + " 總數值為: " + str(sum)

add_to_pos = document["add_to"]
add_to_pos <= int_add(1, 9)
add_to_pos <= html.BR()
</script>
<p><span style="color: #ff0000;">從 Gist 讀取資料</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 將 Brython 程式存入 Gist, 並取得其 url 網址
url = "https://gist.githubusercontent.com/mdecycu/82d5d77b917a5d6c656233767afe4bea/raw/350ea45f6e3f130a15faf98c82b6475c7dcdfef4/rect_walk.py"
# 利用 open() 與 read() 取得程式碼
data = open(url).read()
# 利用 exec() 執行
ns = {'__name__':'__main__'}
exec(data, ns)</pre>
<p>上列從 Gist 讀取程式碼後執行結果:</p>
<div id="brython_div1"></div>
<script type="text/python">
# 將 Brython 程式存入 Gist, 並取得其 url 網址
url = "https://gist.githubusercontent.com/mdecycu/82d5d77b917a5d6c656233767afe4bea/raw/350ea45f6e3f130a15faf98c82b6475c7dcdfef4/rect_walk.py"
# 利用 open() 與 read() 取得程式碼
data = open(url).read()
# 利用 exec() 執行
ns = {'__name__':'__main__'}
exec(data, ns)
</script>
<p><span style="color: #ff0000;">數列應用</span></p>
<p><span style="color: #ff0000;"><span style="color: #000000;">nfu.cycu.org 是一台 Windows 主機, 安裝了 CPython + Flask 程式, 可以透過 AJAX 向教務主機取得與課程相關的資料. 例如: <a href="https://nfu.cycu.org/?semester=1111&amp;courseno=0747&amp;column=True">https://nfu.cycu.org/?semester=1111&amp;courseno=0747&amp;column=True</a> 可以取得 111 學年度第一學期課號為 0747 課程的修課學員學號, 且會在列出學號後跳行, 在網頁中以欄的方式由上往下排列學員學號.</span><br/></span></p>
<p><span style="color: #ff0000;"><span style="color: #000000;">首先看 nfu.cycu.org 上的 CPython 程式碼:</span></span></p>
<p><span style="color: #ff0000;"><span style="color: #000000;">wsgi.py</span></span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from flask import Flask, request 
from flask_cors import CORS
  
import requests
import bs4
#import ssl
  
'''
1a - 2b
?semester=1111&amp;courseno=0747&amp;column=True 

?semester=1111&amp;courseno=0761&amp;column=True 

?semester=1111&amp;courseno=0773&amp;column=True 

?semester=1111&amp;courseno=0786&amp;column=True 

if xx.8 as nfu.cycu.xxx IPv4 address, no proxy needed
'''
proxies ={
'http': 'http://kmolag:kmolab@[2001:288:6004:xx::x]:3128',
'https': 'http://kmolab:kmolab@[2001:288:6004:xx::x]:3128'
}

app = Flask(__name__)
CORS(app)
  
@app.route('/studlist')
@app.route('/')
def studlist():
    semester = request.args.get('semester')
    courseno = request.args.get('courseno')
    column = request.args.get('column')

    if semester == None:
        semester = '1091'
    if courseno == None:
        courseno = '0762'
    
    headers = {'X-Requested-With': 'XMLHttpRequest'}

    url = 'https://qry.nfu.edu.tw/studlist_ajax.php'
    post_var = {'pselyr': semester, 'pseqno': courseno}
  
    #result = requests.post(url, data = post_var, headers = headers, proxies = proxies)
    result = requests.post(url, data = post_var, headers = headers)
    soup = bs4.BeautifulSoup(result.content, 'lxml')
    table = soup.find('table', {'class': 'tbcls'})
    data = []
    rows = table.find_all('tr')
    for row in rows:
        cols = row.find_all('td')
        cols = [ele.text.strip() for ele in cols]
        data.append([ele for ele in cols if ele]) # Get rid of empty values
    output = ""
    for i in data[2:]:
        #print(i[0])
        if column == "True":
            output +=i[0] + "&lt;/br&gt;"
        else:
            output +=i[0] + "\n"
        
    return output
    #return  str(pselyr) + " + " +str(pseqno)
  
# 即使在近端仍希望以 https 模式下執行
#context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
#context.load_cert_chain('localhost.crt', 'localhost.key')
  
if __name__ == '__main__':
    app.run(host='127.0.0.1', port=8080, debug=True)</pre>
<p>而 wsgi.py 是透過 waitress_server.py 啟動:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># pip install waitress
from waitress import serve

# under cmsimde import fossilapp
import wsgi

# run cmsimde dynamic site with production waitress
serve(wsgi.app, host='0.0.0.0', port=5005, url_scheme='https')</pre>
<p>意即, 最終 wsgi.py 在從 waitress_server.py 導入後, 以近端的 5005 port 啟動. 最後的 https 則交由 stunnel 接手:</p>
<p>stunnel.conf</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">[https]
accept = nfu.cycu.org:443
connect = 5005
cert = fullchain.pem
key = privkey.pem
TIMEOUTclose = 0</pre>
<p>之後若利用 Brython 的 open() 與 read() 讀取 <a href="https://nfu.cycu.org/?semester=1111&amp;courseno=0747&amp;column=True">1a 2022 Fall cp 修課學員學號</a>, 並利用每一行最後的跳行符號進行分割, 就可以將各學員的學號放入數列 (List), 再利用 for 迴圈就可以逐一取出學員學號進行運用.</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 已知 cp2022 1a 修課學員學號, 可以輾轉從下列 url 取出
url = "https://nfu.cycu.org/?semester=1111&amp;courseno=0747&amp;column=True"
data = open(url).read()
# 上列 data 為學員學號分別以跳行符號各自列成一列
# 以下利用跳行符號對 data 進行分割, 可以得到型別為 list 的 data 豎列
data = data.split("\n")
# 但取回的資料最後一筆為空白行, 因此數列最後一個元素必須去除
# 冒號前面沒有索引值, 表示從數列的第一個元素開始取用
# 冒號後面加上 -1, 表示數列的取值, 只取到倒數第一位的前一個元素, 也就可以去除最後一個空白元素
data = data[:-1]
print(data)</pre>
<p>上述數列應用的程式執行結果:</p>
<div id="list_ex1"></div>
<script type="text/python">
from browser import document, html
# 已知 cp2022 1a 修課學員學號, 可以輾轉從下列 url 取出
url = "https://nfu.cycu.org/?semester=1111&amp;courseno=0747&amp;column=True"
data = open(url).read()
# 上列 data 為學員學號分別以跳行符號各自列成一列
# 以下利用跳行符號對 data 進行分割, 可以得到型別為 list 的 data 豎列
data = data.split("\n")
# 但取回的資料最後一筆為空白行, 因此數列最後一個元素必須去除
# 冒號前面沒有索引值, 表示從數列的第一個元素開始取用
# 冒號後面加上 -1, 表示數列的取值, 只取到倒數第一位的前一個元素, 也就可以去除最後一個空白元素
data = data[:-1]
#print(data)
output = "["
count = 0
for i in data:
    count = count + 1
    if count == 1:
        output = output + str(i)
    else:
        output = output + ", " + str(i)
list_ex1_pos = document["list_ex1"]
list_ex1_pos <= output + "]"
list_ex1_pos <= html.BR()
</script>
<p><span style="color: #ff0000;">字典應用</span></p>
<p>從 <a href="https://mde.tw/studlist/2022fall/1a.txt">https://mde.tw/studlist/2022fall/1a.txt</a> 可以取得 1a 各學員所提供的 Github 對應帳號, 利用 Brython 程式讀取後, 可以利用 Dictionary 資料型別, 將學員的學號與對應 Github 帳號放入 github_account 字典中, 之後只要透過學號當作索引, 就可以列出該學員的 Github 帳號.</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">stud_1a_url = "https://mde.tw/studlist/2022fall/1a.txt"
data = open(stud_1a_url).read()
# 因為資料中的第一個欄位為學號, 而第二個欄位為 Github 帳號, 且各列資料以 \t 隔開, 因此讀取後先以各列的跳行符號分割, 將各學員的資料先放入數列後再逐一取出分割出學號與 Github 帳號對應值
# 先宣告一個空的字典
num_github = {}
data = data.split("\n")
# 因為第一列資料為標題, 必須利用 data[1:] 表示從索引值第二位開始取用
# 而且最後一筆為空資料, 也必須去除, 因此最後只取用 data[1:-1]
for i in data[1:-1]:
    each_stud = i.split("\t")
    stud_num = each_stud[0]
    github = each_stud[1]
    # 逐一以學號作為字典索引, 對應至各學員的 Github 帳號
    num_github[stud_num] = github

# 試著利用字典列出 41123110 的 Github 帳號
print(num_github["41123110"])
</pre>
<p>上列字典應用程式執行結果:</p>
<div id="dict_ex1"></div>
<script type="text/python">
from browser import document, html
stud_1a_url = "https://mde.tw/studlist/2022fall/1a.txt"
data = open(stud_1a_url).read()
# 因為資料中的第一個欄位為學號, 而第二個欄位為 Github 帳號, 且各列資料以 \t 隔開, 因此讀取後先以各列的跳行符號分割, 將各學員的資料先放入數列後再逐一取出分割出學號與 Github 帳號對應值
# 先宣告一個空的字典
num_github = {}
data = data.split("\n")
# 因為第一列資料為標題, 必須利用 data[1:] 表示從索引值第二位開始取用
# 而且最後一筆為空資料, 也必須去除, 因此最後只取用 data[1:-1]
for i in data[1:-1]:
    each_stud = i.split("\t")
    stud_num = each_stud[0]
    github = each_stud[1]
    # 逐一以學號作為字典索引, 對應至各學員的 Github 帳號
    num_github[stud_num] = github

# 試著利用字典列出 41123110 的 Github 帳號
dict_ex1_pos = document["dict_ex1"]
dict_ex1_pos <= str(num_github["41123110"])
dict_ex1_pos <= html.BR()
</script>
<p><span style="color: #ff0000;">Brython 的 Canvas 靜態繪圖</span></p>
<p>以下為利用 HTML5 Canvas 靜態繪圖範例:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from browser import document, html
# 利用 math 函式庫執行三角函數運算
import math
canvas = html.CANVAS(width = 300, height = 300)
#canvas.id = "star"
# 準備繪圖畫布
star_ex1_pos = document["star_ex1"]
star_ex1_pos &lt;= canvas
ctx = canvas.getContext("2d")

# 建立畫直線函式
def draw_line(x1, y1, x2, y2, color="#ff0000"):
    ctx.beginPath()
    ctx.moveTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.strokeStyle = color
    ctx.stroke()
    
deg = math.pi/180.

# 建立五星繪圖函式
#x, y 為中心, r 為半徑, angle 旋轉角, solid 空心或實心, color 顏色
def star(x, y, r, angle=0, solid=False, color="#ff0000"):
    #以 x, y 為圓心, 計算五個外點
    # 圓心到水平線距離
    a = r*math.cos(72*deg)
    # a 頂點向右到內點距離
    b = (r*math.cos(72*deg)/math.cos(36*deg))*math.sin(36*deg)
    # 利用畢氏定理求內點半徑
    rin = math.sqrt(a*a + b*b)
    # 查驗 a, b 與 rin
    #print(a, b, rin)
    if solid:
        ctx.beginPath()
    # angle 角度先轉 360/10, 讓五星對正
    angle = angle + 360/10
    for i in range(5):
        xout = (x + r*math.sin((360/5)*deg*i+angle*deg))
        yout = (y + r*math.cos((360/5)*deg*i+angle*deg))
        # 外點增量 + 1
        xout2 = x + r*math.sin((360/5)*deg*(i+1)+angle*deg)
        yout2 = y + r*math.cos((360/5)*deg*(i+1)+angle*deg)
        xin = x + rin*math.sin((360/5)*deg*i+36*deg+angle*deg)
        yin = y + rin*math.cos((360/5)*deg*i+36*deg+angle*deg)
        # 查驗外點與內點座標
        #print(xout, yout, xin, yin)
        if solid:
            # 填色
            if i==0:
                ctx.moveTo(xout, yout)
                ctx.lineTo(xin, yin)
                ctx.lineTo(xout2, yout2)
            else:
                ctx.lineTo(xin, yin)
                ctx.lineTo(xout2, yout2)
        else:
            # 空心
            draw_line(xout, yout, xin, yin, color)
            # 畫空心五芒星, 無關畫線次序, 若實心則與畫線次序有關
            draw_line(xout2, yout2, xin, yin, color)
    if solid:
        ctx.fillStyle = color
        ctx.fill()

# 大五星位於 (5x20, 5x20) 半徑為 3x20
# 利用 gold 顏色繪製塗色五星圖案
star(100, 100, 60, solid=True, color="#ffd700")
# 利用紅色描繪五星外圍線條
star(100, 100, 60, solid=False, color="#ff0000")</pre>
<p>上列五星靜態繪圖結果:</p>
<div id="star_ex1"></div>
<script type="text/python">
from browser import document, html
# 利用 math 函式庫執行三角函數運算
import math
canvas = html.CANVAS(width = 300, height = 300)
#canvas.id = "star"
# 準備繪圖畫布
star_ex1_pos = document["star_ex1"]
star_ex1_pos <= canvas
ctx = canvas.getContext("2d")

# 建立畫直線函式
def draw_line(x1, y1, x2, y2, color="#ff0000"):
    ctx.beginPath()
    ctx.moveTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.strokeStyle = color
    ctx.stroke()
    
deg = math.pi/180.

# 建立五星繪圖函式
#x, y 為中心, r 為半徑, angle 旋轉角, solid 空心或實心, color 顏色
def star(x, y, r, angle=0, solid=False, color="#ff0000"):
    #以 x, y 為圓心, 計算五個外點
    # 圓心到水平線距離
    a = r*math.cos(72*deg)
    # a 頂點向右到內點距離
    b = (r*math.cos(72*deg)/math.cos(36*deg))*math.sin(36*deg)
    # 利用畢氏定理求內點半徑
    rin = math.sqrt(a*a + b*b)
    # 查驗 a, b 與 rin
    #print(a, b, rin)
    if solid:
        ctx.beginPath()
    # angle 角度先轉 360/10, 讓五星對正
    angle = angle + 360/10
    for i in range(5):
        xout = (x + r*math.sin((360/5)*deg*i+angle*deg))
        yout = (y + r*math.cos((360/5)*deg*i+angle*deg))
        # 外點增量 + 1
        xout2 = x + r*math.sin((360/5)*deg*(i+1)+angle*deg)
        yout2 = y + r*math.cos((360/5)*deg*(i+1)+angle*deg)
        xin = x + rin*math.sin((360/5)*deg*i+36*deg+angle*deg)
        yin = y + rin*math.cos((360/5)*deg*i+36*deg+angle*deg)
        # 查驗外點與內點座標
        #print(xout, yout, xin, yin)
        if solid:
            # 填色
            if i==0:
                ctx.moveTo(xout, yout)
                ctx.lineTo(xin, yin)
                ctx.lineTo(xout2, yout2)
            else:
                ctx.lineTo(xin, yin)
                ctx.lineTo(xout2, yout2)
        else:
            # 空心
            draw_line(xout, yout, xin, yin, color)
            # 畫空心五芒星, 無關畫線次序, 若實心則與畫線次序有關
            draw_line(xout2, yout2, xin, yin, color)
    if solid:
        ctx.fillStyle = color
        ctx.fill()

# 大五星位於 (5x20, 5x20) 半徑為 3x20
# 利用 gold 顏色繪製塗色五星圖案
star(100, 100, 60, solid=True, color="#ffd700")
# 利用紅色描繪五星外圍線條
star(100, 100, 60, solid=False, color="#ff0000")
</script>
<p><span style="color: #ff0000;">Brython 的 Canvas 動態繪圖</span></p>
<p><span style="color: #000000;">動態繪圖範例:</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 這個程式用於 demo 綠色方塊往隨機產生的紅色方塊位置移動
# 從 Brython 程式庫中的 browser 模組導入 document 類別, 並以簡寫設定為 doc
from browser import document as doc
# 從 browser 模組導入 html 類別, 主要用於建立 CANVAS 標註物件, 並插入頁面中
from browser import html
# 用於定時執行特定函式
import browser.timer
# 導入亂數模組
from random import random, randint

# 利用 html 建立一個 CANVAS 標註物件, 與變數 canvas 對應
canvas = html.CANVAS(width = 600, height = 600)
# 將 canvas 標註的 id 設為 "canvas"
canvas.id = "canvas"
# 將 document 中 id 為 "snake_ex1" 的標註 
# 設為與 sname_ex1 變數對應
snake_ex1_pos = doc["snake_ex1"]
# 將 canvas 標註放入 brython_div 所在位置
# 頁面中原本就已經放入 &lt;div id="snake_ex1"&gt;&lt;/div&gt; 標註
snake_ex1_pos &lt;= canvas
# 將 canvas 的 2d 繪圖 context 命名為 ctx
ctx = canvas.getContext("2d")

# 建立一個 dRect() 函式
# s default 為 1, c default 為紅色
def dRect(lux, luy, w, h, s=1, c='#ff0000'):
    ctx.lineWidth = s
    ctx.strokeStyle = c
    ctx.beginPath();
    ctx.rect(lux, luy, w, h)
    ctx.stroke();
    
# 建立畫直線函式
def draw_line(x1, y1, x2, y2, color="#ff0000"):
    ctx.beginPath()
    ctx.moveTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.strokeStyle = color
    ctx.stroke()

# 建立 write Text 函式
def wText(x, y, t, s=14, c='#0000ff'):
    ctx.font = str(s) + "px Arial";
    ctx.fillText(t, x, y)

# 定義畫格線的函式
def grid(startx, starty, w, h, wnum, hnum, pixel=1, color="#ff0000"):
    # 利用迴圈與座標增量繪圖
    # 因為輸入 wnum 與 hnum 為格子數, 畫格線數則需加上 1
    for i in range(wnum+1):
        for j in range(hnum+1):
            # 畫上下直線
            yend = starty + h*(hnum)
            xend = startx + w*(wnum)
            x = startx + i*w
            draw_line(x, starty, x, yend, color)
            # 畫左右直線
            y = starty + j*h
            draw_line(startx, y, xend, y, color)
            #wText(w/2-10, y-w/2, str(j))

# 從兩個座標點求中心點座標
def center(lx, ly, rx, ry):
    # lx is x coord of the left up corner
    # rx is the x coord of th right down corner
    x = (lx + rx)/2
    y = (ly + ry)/2
    return x, y
    
# 畫出填色方塊
def draw_rect(gx, gy, gw, gh, color="lime"):
    # gx is the grid coord at x direction
    # gy is the grid coord at y direction
    # gw is the width of the green rect
    # gh is the height of the green rect
    lx = origx + (gx-1)*w
    ly = origy + (gy-1)*h
    rx = origx + gx*w
    ry = origy + gy*h
    cx, cy = center(lx, ly, rx, ry)
    # glx is the x coord of the left corner
    # gly is the y coord of the left corner
    glx = cx - gw/2
    gly = cy - gh/2
    # 利用設定的顏色值畫出 rectangle
    ctx.fillStyle = color
    ctx.fillRect(glx, gly, gw, gh)

# 以白色覆蓋位於 (nowx, nowy) 
# 且比目標方塊長寬各大於 1 pixel的方塊
def wipe():
    draw_rect(nowx, nowy, 30+1, 30+1, color="white")

# 畫出位於 (nowx, nowy) 的綠色方塊
def draw():
    draw_rect(nowx, nowy, 30, 30, color="lime")

# 以隨機方式在格點座標中畫出紅色方塊
def draw_red():
    draw_rect(redx, redy, wrect_size, hrect_size, color="red")

# 綠色方塊往紅色方塊位置移動, 抵達目標位置後停止移動
def walk():
    global stepx, stepy
    if nowx &gt; redx:
        stepx = -1
        stepy = 0
    if nowx &lt; redx:
        stepx = 1
        stepy = 0
    if nowy &gt; redy:
        stepx = 0
        stepy = -1
    if nowy &lt; redy:
        stepx = 0
        stepy = 1
    if nowx == redx and nowy == redy:
        stepx = 0
        stepy = 0

# 每隔短暫時間即呼叫執行一次的函式
def game():
    # 因 nowx, nowy, redx, redy 在函式外宣告
    # 且在函式內改變對應值, 因此需宣告為 global
    global nowx, nowy, redx, redy
    # 當綠色方塊移動至紅色方塊座標後, 產生另一個紅色目標座標值
    if nowx == redx and nowy == redy:
        # wnum 為 width 方向的格子數
        # hnum 為 height 方向的格子數
        redx = randint(1, wnum)
        redy = randint(1, hnum)
    draw_red()
    walk()
    wipe()
    nowx += stepx
    nowy += stepy
    draw()

# 綠色方塊起點座標與 x 及 y 方向的座標增量
nowx = 1
nowy = 1
stepx = 0
stepy = 0
go = True
# 設定格數
# width 方向格子數
wnum = 15
# height 方向格子數
hnum = 15
# 紅色方塊座標起始座標位於右下角
redx = wnum-1
redy = hnum-1
# 設定線寬
pixel = 1
# 設定 w 寬度
w = int(canvas.width/wnum) - pixel
# 設定 h 高度
h = int(canvas.height/hnum) - pixel
# 設定紅色方塊寬度與高度, 分別設為格子大小的  70%
wrect_size = int(w*0.7)
hrect_size = int(h*0.7)
# 設定繪圖座標點起點位置
origx = 1
origy = 1
# 利用 grid 函式畫出格線
grid(origx, origy, w, h, wnum, hnum, pixel=1, color="black")

browser.timer.set_interval(game, 100)</pre>
<p>以上動態繪圖結果:</p>
<div id="snake_ex1"></div>
<script type="text/python">
# 這個程式用於 demo 綠色方塊往隨機產生的紅色方塊位置移動
# 從 Brython 程式庫中的 browser 模組導入 document 類別, 並以簡寫設定為 doc
from browser import document as doc
# 從 browser 模組導入 html 類別, 主要用於建立 CANVAS 標註物件, 並插入頁面中
from browser import html
# 用於定時執行特定函式
import browser.timer
# 導入亂數模組
from random import random, randint

# 利用 html 建立一個 CANVAS 標註物件, 與變數 canvas 對應
canvas = html.CANVAS(width = 600, height = 600)
# 將 canvas 標註的 id 設為 "canvas"
canvas.id = "canvas"
# 將 document 中 id 為 "snake_ex1" 的標註 
# 設為與 sname_ex1 變數對應
snake_ex1_pos = doc["snake_ex1"]
# 將 canvas 標註放入 brython_div 所在位置
# 頁面中原本就已經放入 <div id="snake_ex1"></div> 標註
snake_ex1_pos <= canvas
# 將 canvas 的 2d 繪圖 context 命名為 ctx
ctx = canvas.getContext("2d")

# 建立一個 dRect() 函式
# s default 為 1, c default 為紅色
def dRect(lux, luy, w, h, s=1, c='#ff0000'):
    ctx.lineWidth = s
    ctx.strokeStyle = c
    ctx.beginPath();
    ctx.rect(lux, luy, w, h)
    ctx.stroke();
    
# 建立畫直線函式
def draw_line(x1, y1, x2, y2, color="#ff0000"):
    ctx.beginPath()
    ctx.moveTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.strokeStyle = color
    ctx.stroke()

# 建立 write Text 函式
def wText(x, y, t, s=14, c='#0000ff'):
    ctx.font = str(s) + "px Arial";
    ctx.fillText(t, x, y)

# 定義畫格線的函式
def grid(startx, starty, w, h, wnum, hnum, pixel=1, color="#ff0000"):
    # 利用迴圈與座標增量繪圖
    # 因為輸入 wnum 與 hnum 為格子數, 畫格線數則需加上 1
    for i in range(wnum+1):
        for j in range(hnum+1):
            # 畫上下直線
            yend = starty + h*(hnum)
            xend = startx + w*(wnum)
            x = startx + i*w
            draw_line(x, starty, x, yend, color)
            # 畫左右直線
            y = starty + j*h
            draw_line(startx, y, xend, y, color)
            #wText(w/2-10, y-w/2, str(j))

# 從兩個座標點求中心點座標
def center(lx, ly, rx, ry):
    # lx is x coord of the left up corner
    # rx is the x coord of th right down corner
    x = (lx + rx)/2
    y = (ly + ry)/2
    return x, y
    
# 畫出填色方塊
def draw_rect(gx, gy, gw, gh, color="lime"):
    # gx is the grid coord at x direction
    # gy is the grid coord at y direction
    # gw is the width of the green rect
    # gh is the height of the green rect
    lx = origx + (gx-1)*w
    ly = origy + (gy-1)*h
    rx = origx + gx*w
    ry = origy + gy*h
    cx, cy = center(lx, ly, rx, ry)
    # glx is the x coord of the left corner
    # gly is the y coord of the left corner
    glx = cx - gw/2
    gly = cy - gh/2
    # 利用設定的顏色值畫出 rectangle
    ctx.fillStyle = color
    ctx.fillRect(glx, gly, gw, gh)

# 以白色覆蓋位於 (nowx, nowy) 
# 且比目標方塊長寬各大於 1 pixel的方塊
def wipe():
    draw_rect(nowx, nowy, 30+1, 30+1, color="white")

# 畫出位於 (nowx, nowy) 的綠色方塊
def draw():
    draw_rect(nowx, nowy, 30, 30, color="lime")

# 以隨機方式在格點座標中畫出紅色方塊
def draw_red():
    draw_rect(redx, redy, wrect_size, hrect_size, color="red")

# 綠色方塊往紅色方塊位置移動, 抵達目標位置後停止移動
def walk():
    global stepx, stepy
    if nowx > redx:
        stepx = -1
        stepy = 0
    if nowx < redx:
        stepx = 1
        stepy = 0
    if nowy > redy:
        stepx = 0
        stepy = -1
    if nowy < redy:
        stepx = 0
        stepy = 1
    if nowx == redx and nowy == redy:
        stepx = 0
        stepy = 0

# 每隔短暫時間即呼叫執行一次的函式
def game():
    # 因 nowx, nowy, redx, redy 在函式外宣告
    # 且在函式內改變對應值, 因此需宣告為 global
    global nowx, nowy, redx, redy
    # 當綠色方塊移動至紅色方塊座標後, 產生另一個紅色目標座標值
    if nowx == redx and nowy == redy:
        # wnum 為 width 方向的格子數
        # hnum 為 height 方向的格子數
        redx = randint(1, wnum)
        redy = randint(1, hnum)
    draw_red()
    walk()
    wipe()
    nowx += stepx
    nowy += stepy
    draw()

# 綠色方塊起點座標與 x 及 y 方向的座標增量
nowx = 1
nowy = 1
stepx = 0
stepy = 0
go = True
# 設定格數
# width 方向格子數
wnum = 15
# height 方向格子數
hnum = 15
# 紅色方塊座標起始座標位於右下角
redx = wnum-1
redy = hnum-1
# 設定線寬
pixel = 1
# 設定 w 寬度
w = int(canvas.width/wnum) - pixel
# 設定 h 高度
h = int(canvas.height/hnum) - pixel
# 設定紅色方塊寬度與高度, 分別設為格子大小的  70%
wrect_size = int(w*0.7)
hrect_size = int(h*0.7)
# 設定繪圖座標點起點位置
origx = 1
origy = 1
# 利用 grid 函式畫出格線
grid(origx, origy, w, h, wnum, hnum, pixel=1, color="black")

browser.timer.set_interval(game, 100)
</script><h2>wcm</h2>
<p><a href="https://github.com/marcoagner/Flask-QRcode">https://github.com/marcoagner/Flask-QRcode</a> </p>
<p><a href="https://github.com/Vaibhavi24/Online-Hotel-Management-System">https://github.com/Vaibhavi24/Online-Hotel-Management-System</a> </p><h1>CAD</h1>
<p>常見的電腦輔助設計中階套件:</p>
<p style="padding-left: 30px;">AutoDesk Inventor, Solidworks, Solid Edge</p>
<p><span>常見的電腦輔助設計高階套件:</span></p>
<p style="padding-left: 30px;"><span>PTC Creo, <span style="color: #ff0000;">Siemens NX</span>, Dassaults CATIA</span></p>
<p><span>常見的雲端電腦輔助設計套件:</span></p>
<p style="padding-left: 30px;"><span><span style="color: #ff0000;">Onshape</span>, AutoDesk Fusion 360</span></p>
<p><span>開源電腦輔助設計套件:</span></p>
<p style="padding-left: 30px;"><span style="color: #ff0000;">Solvespace</span></p>
<p></p><h2>Solvespace</h2>
<p>要在 Windows 64 位元操作系統中編譯 Solvespace 原始碼, 可以下載 <a href="https://nfuedu.sharepoint.com/:u:/s/cad2022/EeaLUTntsAZBjKrh-e_N_doBX6hV_CAakHv2A2g_Ft6MoA?e=ba2DGF">msys64_20210419_for_cad2022.7z</a> (3.4 GB 解開後 12.5 GB, 必須登入 @nfu OneDrive 帳號後才能下載).</p>
<p>編譯 Solvespace 原始碼 v3.1 步驟如下:</p>
<div>(一) 下載 <a href="https://nfuedu.sharepoint.com/:u:/s/cad2022/EfdRJOC38oNErVbz4uru1loBZvIfMs2f1W39SK6bPYtukA?e=NSkNhD" rel="noreferrer noopener" tabindex="-1" target="_blank" title="https://nfuedu.sharepoint.com/:u:/s/cad2022/efdrjoc38onervbz4uru1lobzvifms2f1w39sk6bpytuka?e=nsknhd">msys64_20210419 for cad2022.7z</a>.</div>
<div></div>
<div>(二) 在 start 批次檔案中增加 msys2 搜尋路徑:</div>
<div></div>
<div style="padding-left: 30px;">REM 設定 msys2 64 位元的執行路徑<br/>set path_msys2=%cd%\msys64_20210419\mingw64\bin;<br/>REM 將 %path_msys2% 加入 path 設定<br/>path=%cd%;%path_python%;%path_git%;%path_tcc%;%path_scite%;%path_msys2%;%path%;</div>
<div style="padding-left: 30px;"></div>
<div>(三) 啟動批次檔案附加 msys2 搜尋路徑後, 必須重新啟動可攜程式系統.</div>
<div></div>
<div>
<div>(四) 接下來取得 Solvespace 原始碼並切換到 v3.1 分支:</div>
<div></div>
<div style="padding-left: 30px;">git clone --recurse-submodules https://github.com/solvespace/solvespace.git<br/>cd solvespace<br/>git checkout v3.1<br/>mkdir build<br/>cd build<br/>cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release<br/>make</div>
<div></div>
<div>(五) 編譯完成後, 位於 solvespace\build\bin 目錄中的 solvespace.exe 需要配合 msys64_20210419\mingw64\bin\libwinpthread-1.dll 檔案才能執行.</div>
<div></div>
<div>Reference:</div>
<div></div>
<div>
<div>
<div style="padding-left: 30px;"><a href="https://nfuedu.sharepoint.com/:u:/s/cad2022/EaPyatU3SS9PgqlZqzIMoEYBAyBazQWurjUinQDW68gpng?e=Scn3Lw" rel="noreferrer noopener" tabindex="-1" target="_blank" title="https://nfuedu.sharepoint.com/:u:/s/cad2022/eapyatu3ss9pgqlzqzimoeybaybazqwurjuinqdw68gpng?e=scn3lw">solvespace v3.1 原始碼, 編譯結果與 Leo Editor 專案.7z</a></div>
<div style="padding-left: 30px;"><a href="https://nfuedu.sharepoint.com/:u:/s/cad2022/EYBFNxzRFCxEnuhXmPsF-fkBs6res9utPvRAoifXhzFDrw?e=LHnNTS" rel="noreferrer noopener" tabindex="-1" target="_blank" title="https://nfuedu.sharepoint.com/:u:/s/cad2022/eybfnxzrfcxenuhxmpsf-fkbs6res9utpvraoifxhzfdrw?e=lhnnts">solvespace.exe compiled with msys2.7z</a></div>
<div style="padding-left: 30px;"><a href="https://github.com/solvespace/solvespace/issues/1303" rel="noreferrer noopener" tabindex="-1" target="_blank" title="https://github.com/solvespace/solvespace/issues/1303">Solvespace Development Documentation</a></div>
</div>
</div>
</div><h3>Solvespace_ex</h3>
<p><a href="https://solvespace.readthedocs.io/en/latest/tutorials/quick_start.html">Quick Start — solvespace latest documentation</a> </p>
<p><a href="http://www.farwire.net/SolveSpace-LearningGuide.htm">SolveSpace - Learning Guide (farwire.net)</a></p>
<p><a href="https://solvespace.com/tutorial.pl">SolveSpace - Tutorials</a></p>
<p><a href="https://solvespace.com/2d.pl">SolveSpace - Tutorial - 2d Sketching</a></p>
<p></p><h2>NX</h2>
<p>下載 <a href="https://nfuedu.sharepoint.com/:u:/s/cad2022/EclS-NMhqJ9JvCa-pIQ_jMsBQB1tipr_Zgc8kT8ha1kMtg?e=CWX91u">NX2027.3401_lite_cad2022.7z</a> (1.96 GB, 登入 @nfu OneDrive 帳號後才能下載)</p>
<p><a href="https://nfuedu.sharepoint.com/:u:/s/cad2022/EZiAOTzHCPpPhyVJhKZ99l8BgPiNM90XN3-L2snCoMY6mQ?e=ZVSBgc">Drill Press 零組件檔案</a></p><h2>Onshape</h2>
<h1>CoppeliaSim</h1>
<p>CoppeliaSim 教育版 4.3.0 rev12 <a href="https://nfuedu.sharepoint.com/:u:/s/cad2022/EWdB5MhlZRJKjt5UiNRebR8BN6_AmU0IX1HC7Y6dnRBzQw">下載</a> (134 MB, 必須登入 @nfu OneDrive 帳號後才能下載).</p>
<p>與 CoppeliaSim 配合使用的可攜程式系統:</p>
<p style="padding-left: 30px;"><span>2022 Fall 最終版的 Python 可攜程式系統為</span><span><span> </span></span><a href="https://nfuedu.sharepoint.com/:u:/s/cad2022/EXABheFswCtEtT5p-9uDN4ABuK3DASC8mKkFzpLA3q7f6g?e=V2ZBNw">portable_python_w10_nx_robodk.7z</a><span><span> </span>(1.03 GB, 必須登入 @nfu OneDrive 帳號後才能下載), 這是在課程第十週釋出的版本, 由於必須配合 NX2027 所採用的 NXOpen for Python API 程式解譯需求, 除了 Python 3.10.6 版之外, 還額外提供 Python 3.8.10 的解譯器版本, 以及</span><span><span> </span></span><a href="https://robodk.com/download">RoboDK 5.5</a><span><span> </span>可攜系統.</span></p><h2>Python script</h2>
<p><span>2022 Fall 最終版的 Python 可攜程式系統為</span><span><span> </span></span><a href="https://nfuedu.sharepoint.com/:u:/s/cad2022/EXABheFswCtEtT5p-9uDN4ABuK3DASC8mKkFzpLA3q7f6g?e=V2ZBNw">portable_python_w10_nx_robodk.7z</a><span><span> </span>(1.03 GB, 必須登入 @nfu OneDrive 帳號後才能下載), 這是在課程第十週釋出的版本, 由於必須配合 NX2027 所採用的 NXOpen for Python API 程式解譯需求, 除了 Python 3.10.6 版之外, 還額外提供 Python 3.8.10 的解譯器版本, 以及</span><span><span> </span></span><a href="https://robodk.com/download">RoboDK 5.5</a><span><span> </span>可攜系統.</span></p>
<p>CoppeliaSim 4.3.0 rev12 可以採 Python script 控制場景中的元件. 但必須在 <span style="color: #ff0000;">C:\CoppeliaSimEdu_4.3.0_rev12\system\usrset.txt</span> 中進行設定:</p>
<p style="padding-left: 30px;">原先 usrset.txt 172 與 173 行內容:</p>
<p style="padding-left: 60px;">defaultPython = // e.g. c:/Python38/python.exe<br/>executeUnsafe = false // recommended to keep false.</p>
<p style="padding-left: 30px;">假設 python.exe 位於 C:\portable_python_w10_nx_robodk\Python38 目錄下, 則為了讓 CoppeliaSim 能夠在場景中解譯 Python script, usrset.txt 的 172 與 173 行必須改為:</p>
<p style="padding-left: 60px;"><span>defaultPython = C:/portable_python_w10_nx_robodk/Python38/python.exe</span><br/><span>executeUnsafe = true</span></p>
<p style="padding-left: 30px;"><span>假如使用 Python 3.10.6 解譯系統, 則 </span>usrset.txt 的 172 與 173 行必須改為:</p>
<p style="padding-left: 60px;"><span>defaultPython =<span> </span>C:/portable_python_w10_nx_robodk/Python310/python.exe</span><br/><span>executeUnsafe = true</span></p>
<p style="padding-left: 30px;"><span>C:\CoppeliaSimEdu_4.3.0_rev12\system\usrset.txt 設定檔案修改之後, CoppeliaSim 必須重新啟動設定才會生效.</span></p><h1>Examples</h1>
<h2>cp2022</h2>
<p>為何學習計算機程式需要建立個人倉儲?</p>
<p style="padding-left: 30px;">從 <a href="https://survey.stackoverflow.co/2022/#overview">Stack Overflow Developer Survey 2022</a> 可得知, 專業的程式開發者將 Git 視為最基本的工具. 而 Git 工具的使用與個人在 Github 的倉儲相結合, 可以有效採分散式的方式管理個人或團隊所開發的程式碼. </p>
<p style="padding-left: 30px;">因此在學習計算機程式時, 若能同時熟悉位於 Github 中個人倉儲的維護, 將可在隨後的應用中採取與專業人士相容的處理流程與模式.</p>
<p>全球資訊網能夠提供甚麼功能或有什麼優點?</p>
<p>Replit, stud.cycu.org 與 localhost 分別代表甚麼?</p>
<p>https, ssh 到底提供使用者那些功能或優點?</p>
<p>Brython 與 Python 有甚麼差別?</p>
<p>能夠直接在瀏覽器中以 Brython 繪製中華民國國旗, 或模擬綠色方塊在方塊格點中任意移動, 代表甚麼?</p>
<p>變數, 字串, 整數, 浮點數, 數列, Tuple, Dictionary, 函式, 重複迴圈, class, 物件導向, 資料庫, 這些名詞對您而言代表甚麼?</p><h3>w17</h3>
<p></p>
<p>函式定義與呼叫</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def length(inch):
    #sum = 0
    #start = 1
    #end = 100
    '''
    for i in range(start,end+1,1):
        sum = sum + i
        #print(i)
    print("由" + str(start) + " 加到 " + str(end) + " 等於:" + str(sum))
    '''
    cm = inch * 2.54
    print(cm)

'''
sumto(1,10)
sumto(3, 100)
'''
length(5)</pre>
<p>列出 Python 關鍵字:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import keyword
print(keyword.kwlist)
'''
['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
'''</pre>
<h3>canvas</h3>
<p><!-- 納入 Brython 環境 -->
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 Brython --></p>
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
<!-- 給定 brython_div1 division 標註 --></p>
<div id="brython_div1"></div>
<p><!-- 加入啟動按鈕後的 Rect 行走程式原始碼 -->
<script type="text/python">
# 這個程式用於 demo 綠色方塊沿著特定網格路徑行走
# 從 Brython 程式庫中的 browser 模組導入 document 類別, 並以簡寫設定為 doc
from browser import document as doc
# 從 browser 模組導入 html 類別, 主要用於建立 CANVAS 標註物件, 並插入頁面中
from browser import html
# 用於定時執行特定函式
import browser.timer
# 導入亂數模組
from random import random, randint
import math

# 利用 html 建立一個 CANVAS 標註物件, 與變數 canvas 對應
canvas = html.CANVAS(width = 600, height = 600)
# 將 canvas 標註的 id 設為 "canvas"
canvas.id = "canvas"
# 將 document 中 id 為 "brython_div" 的標註 
# 設為與 brython_div 變數對應
brython_div = doc["brython_div1"]

# 建立 buttons
brython_div <= html.BUTTON("啟動", id="power")
brython_div <= html.BR()

# 將 canvas 標註放入 brython_div1 所在位置
# 頁面中原本就已經放入 <div id="brython_div"></div> 標註
brython_div <= canvas
# 將頁面中 id 為 canvas 的 CANVAS 設為與 canvas 變數對應
canvas = doc["canvas"]
# 將 canvas 的 2d 繪圖 context 命名為 ctx
ctx = canvas.getContext("2d")

# 建立一個 dRect() 函式
# s default 為 1, c defaul 為紅色
def dRect(lux, luy, w, h, s=1, c='#ff0000'):
    ctx.lineWidth = s
    ctx.strokeStyle = c
    ctx.beginPath();
    ctx.rect(lux, luy, w, h)
    ctx.stroke();
    
# 建立畫直線函式
def draw_line(x1, y1, x2, y2, color="#ff0000"):
    ctx.beginPath()
    ctx.moveTo(x1, y1)
    ctx.lineTo(x2, y2)
    ctx.strokeStyle = color
    ctx.stroke()

# 建立 write Text 函式
def wText(x, y, t, s=14, c='#0000ff'):
    ctx.font = str(s) + "px Arial";
    ctx.fillText(t, x, y)

# 定義畫格線的函式
def grid(startx, starty, w, h, wnum, hnum, pixel=1, color="#ff0000"):
    # 利用迴圈與座標增量繪圖
    # 因為輸入 wnum 與 hnum 為格子數, 畫格線數則需加上 1
    for i in range(wnum+1):
        for j in range(hnum+1):
            # 畫上下直線
            yend = starty + h*(hnum)
            xend = startx + w*(wnum)
            x = startx + i*w
            draw_line(x, starty, x, yend, color)
            # 畫左右直線
            y = starty + j*h
            draw_line(startx, y, xend, y, color)
            #wText(w/2-10, y-w/2, str(j))

# 從兩個座標點求中心點座標
def center(lx, ly, rx, ry):
    # lx is x coord of the left up corner
    # rx is the x coord of th right down corner
    x = (lx + rx)/2
    y = (ly + ry)/2
    return x, y
    
# 畫出填色方塊
def draw_rect(gx, gy, gw, gh, color="lime"):
    # gx is the grid coord at x direction
    # gy is the grid coord at y direction
    # gw is the with of the green rect
    # gh is the height of the green rect
    lx = origx + (gx-1)*w
    ly = origy + (gy-1)*h
    rx = origx + gx*w
    ry = origy + gy*h
    cx, cy = center(lx, ly, rx, ry)
    # glx is the x coord of the left corner
    # gly is the y coord of the left corner
    glx = cx - gw/2
    gly = cy - gh/2
    # 利用設定的顏色值畫出 rectangle
    ctx.fillStyle = color
    ctx.fillRect(glx, gly, gw, gh)

# 以白色覆蓋位於 (nowx, nowy) 
# 且比目標方塊長寬各大於 1 pixel的方塊
def wipe():
    draw_rect(nowx, nowy, 30+1, 30+1, color="white")

# 畫出位於 (nowx, nowy) 的綠色方塊
def draw():
    draw_rect(nowx, nowy, 30, 30, color="lime")

# 繞著外圍行走
def walk():
    global stepx, stepy
    # 向下
    if nowy < hnum and nowx == 1:
        stepx = 0
        stepy = 1
    # 向右
    elif nowx < wnum and nowy == hnum:
        stepx = 1
        stepy = 0
    # 向上
    elif nowy == hnum and nowx == wnum:
        stepx = 0
        stepy = -1
    # 向左
    elif nowx == wnum and nowy == 1:
        stepx = -1
        stepy = 0
        
# 每隔短暫時間即呼叫執行一次的函式
def game():
    # 因 nowx 與 nowy 在函式外宣告
    # 且在函式內改變對應值, 因此需宣告為 global
    global nowx, nowy
    walk()
    wipe()
    nowx += stepx
    nowy += stepy
    draw()

# 將 anim 設為 None
anim = None
 
def launchAnimation(ev):
    global anim
    # 初始啟動, anim 為 None
    if anim is None:
        # 每 0.08 秒執行一次 draw 函式繪圖
        #anim = timer.set_interval(draw, 80)
        anim = browser.timer.set_interval(game, 100)
        # 初始啟動後, 按鈕文字轉為"暫停"
        doc['power'].text = '暫停'
    elif anim == 'hold':
        # 當 anim 為 'hold' 表示曾經暫停後的啟動, 因此持續以 set_interval() 持續旋轉, 且將 power 文字轉為"暫停"
        #anim = timer.set_interval(draw, 80)
        anim = browser.timer.set_interval(game, 100)
        doc['power'].text = '暫停'
    else:
        # 初始啟動後, 使用者再按 power, 此時 anim 非 None 也不是 'hold', 因此會執行 clear_interval() 暫停
        # 且將 anim 變數設為 'hold', 且 power 文字轉為"繼續"
        #timer.clear_interval(anim)
        browser.timer.clear_interval(anim)
        anim = 'hold'
        doc['power'].text = '繼續'
        
# 綠色方塊起點座標與 x 及 y 方向的座標增量
nowx = 1
nowy = 1
stepx = 0
stepy = 0
# 設定格數
# width 方向格子數
wnum = 15
# height 方向格子數
hnum = 15
# 設定線寬
pixel = 1
# 設定 w 寬度
w = int(canvas.width/wnum) - pixel
# 設定 h 高度
h = int(canvas.height/hnum) - pixel
# 設定繪圖座標點起點位置
origx = 1
origy = 1
# 利用 grid 函式畫出格線
#grid(origx, origy, w, h, wnum, hnum, pixel=1, color="black")
#draw_line(0, 0, 600, 600, color="black")

ctx.beginPath()
ctx.arc(100, 75, 50, 0, math.pi)
ctx.stroke()

doc["power"].bind("click", launchAnimation)
#browser.timer.set_interval(game, 100)
</script>
</p>
<p>關鍵程式碼:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">#grid(origx, origy, w, h, wnum, hnum, pixel=1, color="black")
#draw_line(0, 0, 600, 600, color="black")

ctx.beginPath()
ctx.arc(100, 75, 50, 0, math.pi)
ctx.stroke()</pre>