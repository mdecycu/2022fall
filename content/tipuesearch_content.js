var tipuesearch = {"pages": [{'title': 'About', 'text': '網站:  https://mde.tw/2022fall \xa0 \n 倉儲:  https://github.com/mdecycu/2022fall \xa0 \n 本網站主要統整 2022 Fall  計算機程式 以及 電腦輔助設計與實習 課程的相關內容、議題與對策. \n 2022 Fall 最終版的 Python 可攜程式系統為  portable_python_w10_nx_robodk.7z  (1.03 GB, 必須登入 @nfu OneDrive 帳號後才能下載), 這是在課程第十週釋出的版本, 由於必須配合 NX2027 所採用的 NXOpen for Python API 程式解譯需求, 除了 Python 3.10.6 版之外, 還額外提供 Python 3.8.10 的解譯器版本, 以及  RoboDK 5.5  可攜系統. \n 相關課程: \n 網際內容管理  https://mde.tw/wcm2023 \xa0 \n 協同產品設計實習  https://mde.tw/cd2023 \xa0', 'tags': '', 'url': 'About.html'}, {'title': 'networking', 'text': 'IPv4 與 IPv6 是兩種不同架構的網路協定, 由於 IPv4 網路協定已經不敷目前網路應用所需, 因此衍生出 IPv6 網路協定. 但由於 IPv4 網路協定已經使用超過 40 年, 因此仍會存在很長一段時間. 在可見的未來, IPv4 與 IPv6 網路協定將會同時存在. \n 在 Windows 操作系統可在命令列以 ipconfig /all 取的與 internet protocol configuration 有關的資訊. \n 若電腦環境只提供 IPv4 網路協定, 但需要透過特定網路協定 (包括 http(s), ssh, sftp 等協定) 與只支援 IPv6 網路協定的網站進行資料交換, 就必須設定能夠提供雙網路 (IPv4 與 IPv6) 協定的代理主機 (Proxy server). \n http(s): \n 在 Windows 操作系統下, Edge 與 Chrome 只能使用操作系統設定的代理主機, 而 Firefox 與 Waterfox 則可以使用操作系統的代理主機設定, 或者自行設定連線的代理主機. \n ssh (sftp): \n 在 Windows 操作系統下的 ssh 網路協定, 可以利用 putty 進行設定, 並以 session 名稱代表 putty 中與 proxy 及 Auth (認證) 有關的設定. putty 中的 puttygen.exe 可以建立 OpenSSH 格式的 public key, 以及 putty 格式的 private key. 為了在近端連線到 Github, OpenSSH 格式的 public key 必須送到 Github 帳號下 Settings 的 SSH and GPG keys 區. 而 putty 中有關 session 的設定則會被存入以下登錄區: \n 電腦\\HKEY_CURRENT_USER\\SOFTWARE\\SimonTatham\\PuTTY \n 另外, 在 Windows 操作系統希望採用 putty 設定 git 連線用的 ssh, 必須在啟動可攜系統時, 宣告: \n set GIT_SSH=%cd%\\putty\\plink.exe \n 在 Linux 操作系統下的 ssh 網路協定, 可以利用 ssh-keygen 建立, 內定的 keys 將會存入使用者工作目錄下的 .ssh 目錄, 且以 id_rsa 與 id_rsa.pub 代表其 private key 與 public key. 至於 Linux 環境下的 ssh proxy 設定, 則位於 .ssh/config 檔案中, config 的設定格式為: \n Host demo \n User git \n Hostname github.com \n ProxyCommand /usr/bin/ncat --proxy p4.cycu.org:3128 --proxy-type http %h %p', 'tags': '', 'url': 'networking.html'}, {'title': 'cmsimde', 'text': 'https://github.com/mdecycu/cmsimde \xa0是一套利用 Python +  Flask  建立的網際內容管理系統. \n 了解 cmsimde 的設計理念與架構, 將有助於有效運用這一套系統. \n cmsimde 主要讓使用者可以利用  Github  倉儲建立靜態網站, 並可在近端與 Windows 或 Linux 操作系統上建立動態網站. \n 所謂靜態網站指的是一個 WWW 全球資訊網伺服器, 只負責伺服 html 網頁、  Javascript  程式以及相關檔案. \n 之所以稱為靜態, 是指此網頁除了透過在客戶端 (瀏覽器) 上執行的 Javascript 程式外, 無伺服器上的程式可直接改變網站內容, 且網站上沒有讓使用者 login 的機制. \n 相較之下, 所謂動態網站, 則指具備 login 機制, 使用者登入網際內容管理系統後, 可以直接更動網站內容. \n 利用 cmsimde 建立的動態網站可以轉為靜態網站內容.\xa0 \n 能夠執行 cmsimde 動態網站的 Python 需要安裝下列模組: \n flask flask_cors bs4 lxml pelican markdown pyopenssl \n 而在近端為了管理 cmsimde 中的網際簡報與網誌, 通常建議再加裝 leo 模組, 因此希望執行 cmsimde 動態網站的 Python 環境, 需要以 pip 安裝所需模組: \n pip install flask flask_cors bs4 lxml pelican markdown leo pyopenssl \xa0', 'tags': '', 'url': 'cmsimde.html'}, {'title': 'Leo Editor', 'text': "Leo Editor 可以利用以下程式 recursively import 原始程式 (放入 body panel 後 按 Ctrl + b 執行): \n '''Recursively import all python files in a directory and clean the result.'''\nc.recursiveImport(\n    dir_ = r'./',\n    kind = '@clean', # The new best practice.\n    safe_at_file = False,\n    theTypes = None, # Same as ['.py']\n) \n", 'tags': '', 'url': 'Leo Editor.html'}, {'title': 'Git', 'text': 'Git 是在 2005 年為了有效管理 Linux 操作系統的原始碼而建立. 具有分散式版次管理的特性, 在多人協同開發程式碼的過程, 可以清楚看出各程式段由誰貢獻, 且其分支架構可以讓使用者切出不會影響主分支的版本進行改版, 一旦主分支之外的版本完成後, 可以選擇將改版功能合併至主分支或保留紀錄. \n 在可攜程式環境中所提供的 git.exe 指令程式來自\xa0 Git - Downloading Package (git-scm.com) \xa0中的 portablegit.', 'tags': '', 'url': 'Git.html'}, {'title': 'Github', 'text': '', 'tags': '', 'url': 'Github.html'}, {'title': 'Pages', 'text': '', 'tags': '', 'url': 'Pages.html'}, {'title': 'Classroom', 'text': '', 'tags': '', 'url': 'Classroom.html'}, {'title': 'QandA', 'text': '使用 Github 免費帳號, 有單一檔案容量大小的限制, 若在近端改版時帶有無法 push 至 Github 倉儲的大容量檔案, 該如何處理? \n \n Github 有關改版檔案大小限制的說明: \n \n About large files on GitHub - GitHub Docs \n \n GitHub limits the size of files you can track in regular Git repositories. \n \n If you attempt to add or update a file that is larger than 50 MB, you will receive a warning from Git. The changes will still successfully push to your repository, but you can consider removing the commit to minimize performance impact. \n \n 改版提交單一檔案容量大小限制為  50 MB . 但是若提交單一檔案 50 MB 時, 將會影響工作效率. \n \n 至於利用瀏覽器, 將檔案上傳至 Github 倉儲的單一檔案容量限制則為  25 MB . \n \n Github 針對 已經新增提交 單一檔案超過 50 MB 的處理 如下 : \n \n 在命令列執行指令, 刪除超過容量的大檔案, 若檔案名稱為 big_file.mp4 \n \n git rm --cached big_file.mp4 \n \n 接著執行下列指令進行訂正 (amend): \n \n git commit --amend -CHEAD \n \n 然後再將訂正後的版本推送到 Github: \n \n git push \n \n 其他可行的處理方式, 請參考  https://mde.tw/demo/content/Windows.html  , 看看你是哪種情況: \n \n 近端改版尚未提交, 僅對某些檔案進行變更, 但希望刪除這些變更: git checkout . (表示將近端檔案與遠端保持同步). \n 近端改版已經提交但尚未推送, 希望刪除這些變更: git reset --soft HEAD~, 或者再加上希望刪除的前幾次變更數字. \n 近端改版已經推送, 但希望刪除這些提交推送的改版內容: git revert 版次號 --no-edit \n \n', 'tags': '', 'url': 'QandA.html'}, {'title': 'repo', 'text': '', 'tags': '', 'url': 'repo.html'}, {'title': 'localhost', 'text': '在近端(也就是使用者工作的電腦)維護 Github 的倉儲, 有兩種認證方法, 可採用 SSH 認證, 或者採用 Github Token 認證. 而認證的目的是讓擁有 Github 倉儲維護權限的用戶, 可以將近端的改版內容推到 Github 雲端儲存. \n 採用 Github Token 認證: \n', 'tags': '', 'url': 'localhost.html'}, {'title': 'Replit', 'text': '', 'tags': '', 'url': 'Replit.html'}, {'title': 'Stud', 'text': '', 'tags': '', 'url': 'Stud.html'}, {'title': 'Python', 'text': 'Python 是一種解譯式程式語言, 使用者編寫程式碼後, 可以直接執行, 從使用者要求 Python 程式執行時, 解譯器 (Interpreter) 會即時將原始碼轉為 Byte code, 然後根據所在操作系統的二位元檔案格式轉為可以執行的格式後執行. \n 與解譯式程式語言相對的是編譯式程式語言, 例如: C/C++ 或 Rust 等. 編譯器稱為 Compiler, 當使用者完成 C 或 C++ 程式開發後, 通常需要進行編譯 (Compile) 與連結 (Link) 等過程, 才能得到可以執行的命令檔案. \n 最早出現的 Python 解譯器, 是採用 C 程式語言編寫的, 稱為 CPython. 此外也有採用 Python 編寫的 Python 解譯器, 稱為  Pypy . 也又用 Java 編寫的 Python 解譯器, 稱為  Jython . 以及採用 .NET 技術編寫的  IronPython . \n 至於利用 Javascript 編寫的 Python 解譯器, 其中一種稱為  Brython . \n Brython 的執行機制是讓使用者在網頁中導入以 Javascript 編寫的 Python 解譯器程式庫之後, 再將使用者寫在網頁超文件 <script type="text/python"></script> 標註中的 Python 程式碼轉為 Javascript 後執行. \n Brython 是一種網頁前端的 Python 程式語言 , 由於 Brython 程式碼的執行需要在客戶端的瀏覽器, 將伺服器中的 Brython 解譯器下載至客戶端, 之後下載伺服器上所要執行的 Brython 程式原始碼之後, 才能利用瀏覽器中的 Javascript 解譯器進行轉檔後執行, 因此: \n Brython 並沒有 CPython 眾多的各式程式庫檔案 , 而比較適合如 Javascript 解譯器一樣, 讓網站開發者將輕巧的 Brython 程式碼放在網頁中, 並設法與位於伺服器中的其他 CPython 程式結合使用. 以便達到較少延遲的網頁互動反應效能. \n Brython 在網站前端, 加上伺服器後端的 CPython 結合應用機制, 就如同  Node.js  或  Deno  網站程式開發機制.', 'tags': '', 'url': 'Python.html'}, {'title': 'Brython', 'text': 'cmsite: wcms use  https://github.com/mdecycu/cmsimde  as submodule \n https://en.wikipedia.org/wiki/Python_(programming_language) \n Examples: \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python Tutorial: \n https://docs.python.org/3/tutorial/ \n An informal introduction to Python \n Indentation \n Variables \n Comments \n Numbers \n Strings \n print \n Python control flow tools \n for \n if \n range \n open \n read \n lists \n tuples \n dictionaries \n functions \n try ... except \n break \n pass \n classes \n 這個頁面 demo 如何在同一頁面下納入多個線上 Ace 編輯器與執行按鈕 ( practice_html.txt  動態頁面超文件). \n practice_html.txt  動態頁面超文件應該可以在啟動 Brython 時, 設定將 .py 檔案放入 downloads/py 目錄中引用. \n 亦即將所有對應的 html 也使用 Brython 產生, 然後寫為  class  後, 在範例導入時透過  instance  引用. \n <!-- 啟動 Brython -->\n<script>\nwindow.onload=function(){\nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']});\n}\n</script> \n 從 1 累加到 100: \n 1 add to 100 \n 將 iterable 與 iterator  相關說明 , 利用 Brython 與 Ace Editor 整理在這個頁面. \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從 1 累加到 100 part2: \n 1 add to 100 cango_three_gears BSnake AI Tetris \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n Filename:  .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n Run   Output   清除輸出區 清除繪圖區 Reload \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n', 'tags': '', 'url': 'Brython.html'}, {'title': 'cp', 'text': '\n \n \n Computer Programming 計算機程式 \n 以 Python 程式語言學習計算機程式需要會甚麼? \n 變數宣告 \n 變數訂定規則 \n \n 不可使用 Python 關鍵字作為變數 \n 只能以英文大小寫或 _ (底線) 作為變數開頭 \n 變數名稱分別英文大寫與小寫 \n \n Python 程式語言的關鍵字: \n \n \n 變數宣告範例: \n # 使用 temp 作為變數名稱, 並與整數 30 對應\ntemp = 30\n# 這時印出 temp 的對應值, 就會是 30\nprint(temp)\n\n# for 迴圈所使用的 index 變數 i 無需在迴圈之前進行宣告.\n# 以下程式會印出 0, 1, 2, 3,4 等五個整數.\nfor i in range(5):\n    print(i) \n 資料型別轉換 \n int(in) 可以將輸入的 in 變數轉為整數 (integer) \n float(in) 可以將輸入的 in 變數轉為浮點數 (floating number) \n str(in) 可以將輸入的 in 變數轉為字串 (string) \n # 變數 a 與 1 對應\na = 1\n# 若要讓 a 的對應值與其他字串相加, 則 a 必須從整數轉為字串\n# 整數可以利用 str() 轉為字串\nprint("a 的對應值為:"  + str(a)) \n 上面整數轉字串程式執行結果: \n \n \n 資料的基本運算 \n 資料包含 integer, floating number 與 string \n 整數與浮點數可以進行加、減、乘與除運算. \n 字串則可進行加與乘運算. \n # 以下可以利用 for 重複迴圈進行整數累加\n# 先設定累加總和變數為 sum\n# 一開始尚未進行整數累加, sum 的對應值為 0\nsum = 0\n# 接著利用 for 迴圈以特定增量值產生希望進入累加的整數\nfor i in range(1, 10):\n    # 假設從 1 要累加到 9, 則上列迴圈可以將增量後的整數對應到 i 變數\n    sum = sum + i\n    # 當迴圈逐一產生增量後的 i 整數後, 分別與當時的 sum 對應值累加\n# 當 i 增加到 9 時, 程式的執行就會跳出 for 環圈, 這時就可以印出累加後的總整數值\nprint("從 1 累加到 9 總數值為: " + str(sum)) \n 以上累加程式執行結果: \n \n \n 從 1 累加到 100 但是避開數字有 3 的整數: \n # 以下可以利用 for 重複迴圈進行整數累加\n# 先設定累加總和變數為 sum\n# 一開始尚未進行整數累加, sum 的對應值為 0\nsum = 0\nend = 100\ncheck = 0\n# 接著利用 for 迴圈以特定增量值產生希望進入累加的整數\nfor i in range(1, end + 1):\n    # 若數字中有 3, 則 pass 表示不進行累加\n    if "3" in str(i):\n        check = check + i\n        print(i, end=", ")\n    else:\n        sum = sum + i\nprint("\\n從 1 累加到 " + str(end) + " 除了數字中有 3 者, 其總數值為: " + str(sum))\nprint(sum + check) \n 以上整數累加但避開帶有特定數字的整數運算結果: \n \n \n 函式定義與呼叫 \n def 為 define 的縮寫, 在 Python 程式語法, 可以利用 def 定義函式. \n # 將累加程式寫為函式, start 輸入變數為累加起始整數, 然後增量 1 累加至 end 整數\ndef int_add(start, end):\n    sum = 0\n    for i in range(start, end+1):\n        sum = sum + i\n    return "從 " + str(start) + " 累加到 " + str(end) + " 總數值為: " + str(sum)\n\nint_add(1, 9) \n 上列累加函式定義與呼叫執行結果為: \n \n \n 函式定義與呼叫 \n def 為 define 的縮寫, 在 Python 程式語法, 可以利用 def 定義函式. \n # 將累加程式寫為函式, start 輸入變數為累加起始整數, 然後增量 1 累加至 end 整數\ndef int_add(start, end):\n    sum = 0\n    for i in range(start, end+1):\n        sum = sum + i\n    return "從 " + str(start) + " 累加到 " + str(end) + " 總數值為: " + str(sum)\n\nint_add(1, 9) \n 上列累加函式定義與呼叫執行結果為: \n \n \n \n \n 從 Gist 讀取資料 \n # 將 Brython 程式存入 Gist, 並取得其 url 網址\nurl = "https://gist.githubusercontent.com/mdecycu/82d5d77b917a5d6c656233767afe4bea/raw/350ea45f6e3f130a15faf98c82b6475c7dcdfef4/rect_walk.py"\n# 利用 open() 與 read() 取得程式碼\ndata = open(url).read()\n# 利用 exec() 執行\nns = {\'__name__\':\'__main__\'}\nexec(data, ns) \n 上列從 Gist 讀取程式碼後執行結果: \n \n \n 數列應用 \n nfu.cycu.org 是一台 Windows 主機, 安裝了 CPython + Flask 程式, 可以透過 AJAX 向教務主機取得與課程相關的資料. 例如:\xa0 https://nfu.cycu.org/?semester=1111&courseno=0747&column=True \xa0可以取得 111 學年度第一學期課號為 0747 課程的修課學員學號, 且會在列出學號後跳行, 在網頁中以欄的方式由上往下排列學員學號. \n 首先看 nfu.cycu.org 上的 CPython 程式碼: \n wsgi.py \n from flask import Flask, request \nfrom flask_cors import CORS\n  \nimport requests\nimport bs4\n#import ssl\n  \n\'\'\'\n1a - 2b\n?semester=1111&courseno=0747&column=True \n\n?semester=1111&courseno=0761&column=True \n\n?semester=1111&courseno=0773&column=True \n\n?semester=1111&courseno=0786&column=True \n\nif xx.8 as nfu.cycu.xxx IPv4 address, no proxy needed\n\'\'\'\nproxies ={\n\'http\': \'http://kmolag:kmolab@[2001:288:6004:xx::x]:3128\',\n\'https\': \'http://kmolab:kmolab@[2001:288:6004:xx::x]:3128\'\n}\n\napp = Flask(__name__)\nCORS(app)\n  \n@app.route(\'/studlist\')\n@app.route(\'/\')\ndef studlist():\n    semester = request.args.get(\'semester\')\n    courseno = request.args.get(\'courseno\')\n    column = request.args.get(\'column\')\n\n    if semester == None:\n        semester = \'1091\'\n    if courseno == None:\n        courseno = \'0762\'\n    \n    headers = {\'X-Requested-With\': \'XMLHttpRequest\'}\n\n    url = \'https://qry.nfu.edu.tw/studlist_ajax.php\'\n    post_var = {\'pselyr\': semester, \'pseqno\': courseno}\n  \n    #result = requests.post(url, data = post_var, headers = headers, proxies = proxies)\n    result = requests.post(url, data = post_var, headers = headers)\n    soup = bs4.BeautifulSoup(result.content, \'lxml\')\n    table = soup.find(\'table\', {\'class\': \'tbcls\'})\n    data = []\n    rows = table.find_all(\'tr\')\n    for row in rows:\n        cols = row.find_all(\'td\')\n        cols = [ele.text.strip() for ele in cols]\n        data.append([ele for ele in cols if ele]) # Get rid of empty values\n    output = ""\n    for i in data[2:]:\n        #print(i[0])\n        if column == "True":\n            output +=i[0] + "</br>"\n        else:\n            output +=i[0] + "\\n"\n        \n    return output\n    #return  str(pselyr) + " + " +str(pseqno)\n  \n# 即使在近端仍希望以 https 模式下執行\n#context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)\n#context.load_cert_chain(\'localhost.crt\', \'localhost.key\')\n  \nif __name__ == \'__main__\':\n    app.run(host=\'127.0.0.1\', port=8080, debug=True) \n 而 wsgi.py 是透過 waitress_server.py 啟動: \n # pip install waitress\nfrom waitress import serve\n\n# under cmsimde import fossilapp\nimport wsgi\n\n# run cmsimde dynamic site with production waitress\nserve(wsgi.app, host=\'0.0.0.0\', port=5005, url_scheme=\'https\') \n 意即, 最終 wsgi.py 在從 waitress_server.py 導入後, 以近端的 5005 port 啟動. 最後的 https 則交由 stunnel 接手: \n stunnel.conf \n [https]\naccept = nfu.cycu.org:443\nconnect = 5005\ncert = fullchain.pem\nkey = privkey.pem\nTIMEOUTclose = 0 \n 之後若利用 Brython 的 open() 與 read() 讀取  1a 2022 Fall cp 修課學員學號 , 並利用每一行最後的跳行符號進行分割, 就可以將各學員的學號放入數列 (List), 再利用 for 迴圈就可以逐一取出學員學號進行運用. \n # 已知 cp2022 1a 修課學員學號, 可以輾轉從下列 url 取出\nurl = "https://nfu.cycu.org/?semester=1111&courseno=0747&column=True"\ndata = open(url).read()\n# 上列 data 為學員學號分別以跳行符號各自列成一列\n# 以下利用跳行符號對 data 進行分割, 可以得到型別為 list 的 data 豎列\ndata = data.split("\\n")\n# 但取回的資料最後一筆為空白行, 因此數列最後一個元素必須去除\n# 冒號前面沒有索引值, 表示從數列的第一個元素開始取用\n# 冒號後面加上 -1, 表示數列的取值, 只取到倒數第一位的前一個元素, 也就可以去除最後一個空白元素\ndata = data[:-1]\nprint(data) \n 上述數列應用的程式執行結果: \n \n \n 字典應用 \n 從\xa0 https://mde.tw/studlist/2022fall/1a.txt \xa0可以取得 1a 各學員所提供的 Github 對應帳號, 利用 Brython 程式讀取後, 可以利用 Dictionary 資料型別, 將學員的學號與對應 Github 帳號放入 github_account 字典中, 之後只要透過學號當作索引, 就可以列出該學員的 Github 帳號. \n stud_1a_url = "https://mde.tw/studlist/2022fall/1a.txt"\ndata = open(stud_1a_url).read()\n# 因為資料中的第一個欄位為學號, 而第二個欄位為 Github 帳號, 且各列資料以 \\t 隔開, 因此讀取後先以各列的跳行符號分割, 將各學員的資料先放入數列後再逐一取出分割出學號與 Github 帳號對應值\n# 先宣告一個空的字典\nnum_github = {}\ndata = data.split("\\n")\n# 因為第一列資料為標題, 必須利用 data[1:] 表示從索引值第二位開始取用\n# 而且最後一筆為空資料, 也必須去除, 因此最後只取用 data[1:-1]\nfor i in data[1:-1]:\n    each_stud = i.split("\\t")\n    stud_num = each_stud[0]\n    github = each_stud[1]\n    # 逐一以學號作為字典索引, 對應至各學員的 Github 帳號\n    num_github[stud_num] = github\n\n# 試著利用字典列出 41123110 的 Github 帳號\nprint(num_github["41123110"])\n \n 上列字典應用程式執行結果: \n \n \n Brython 的 Canvas 靜態繪圖 \n 以下為利用 HTML5 Canvas 靜態繪圖範例: \n from browser import document, html\n# 利用 math 函式庫執行三角函數運算\nimport math\ncanvas = html.CANVAS(width = 300, height = 300)\n#canvas.id = "star"\n# 準備繪圖畫布\nstar_ex1_pos = document["star_ex1"]\nstar_ex1_pos <= canvas\nctx = canvas.getContext("2d")\n\n# 建立畫直線函式\ndef draw_line(x1, y1, x2, y2, color="#ff0000"):\n    ctx.beginPath()\n    ctx.moveTo(x1, y1)\n    ctx.lineTo(x2, y2)\n    ctx.strokeStyle = color\n    ctx.stroke()\n    \ndeg = math.pi/180.\n\n# 建立五星繪圖函式\n#x, y 為中心, r 為半徑, angle 旋轉角, solid 空心或實心, color 顏色\ndef star(x, y, r, angle=0, solid=False, color="#ff0000"):\n    #以 x, y 為圓心, 計算五個外點\n    # 圓心到水平線距離\n    a = r*math.cos(72*deg)\n    # a 頂點向右到內點距離\n    b = (r*math.cos(72*deg)/math.cos(36*deg))*math.sin(36*deg)\n    # 利用畢氏定理求內點半徑\n    rin = math.sqrt(a*a + b*b)\n    # 查驗 a, b 與 rin\n    #print(a, b, rin)\n    if solid:\n        ctx.beginPath()\n    # angle 角度先轉 360/10, 讓五星對正\n    angle = angle + 360/10\n    for i in range(5):\n        xout = (x + r*math.sin((360/5)*deg*i+angle*deg))\n        yout = (y + r*math.cos((360/5)*deg*i+angle*deg))\n        # 外點增量 + 1\n        xout2 = x + r*math.sin((360/5)*deg*(i+1)+angle*deg)\n        yout2 = y + r*math.cos((360/5)*deg*(i+1)+angle*deg)\n        xin = x + rin*math.sin((360/5)*deg*i+36*deg+angle*deg)\n        yin = y + rin*math.cos((360/5)*deg*i+36*deg+angle*deg)\n        # 查驗外點與內點座標\n        #print(xout, yout, xin, yin)\n        if solid:\n            # 填色\n            if i==0:\n                ctx.moveTo(xout, yout)\n                ctx.lineTo(xin, yin)\n                ctx.lineTo(xout2, yout2)\n            else:\n                ctx.lineTo(xin, yin)\n                ctx.lineTo(xout2, yout2)\n        else:\n            # 空心\n            draw_line(xout, yout, xin, yin, color)\n            # 畫空心五芒星, 無關畫線次序, 若實心則與畫線次序有關\n            draw_line(xout2, yout2, xin, yin, color)\n    if solid:\n        ctx.fillStyle = color\n        ctx.fill()\n\n# 大五星位於 (5x20, 5x20) 半徑為 3x20\n# 利用 gold 顏色繪製塗色五星圖案\nstar(100, 100, 60, solid=True, color="#ffd700")\n# 利用紅色描繪五星外圍線條\nstar(100, 100, 60, solid=False, color="#ff0000") \n 上列五星靜態繪圖結果: \n \n \n Brython 的 Canvas 動態繪圖 \n 動態繪圖範例: \n # 這個程式用於 demo 綠色方塊往隨機產生的紅色方塊位置移動\n# 從 Brython 程式庫中的 browser 模組導入 document 類別, 並以簡寫設定為 doc\nfrom browser import document as doc\n# 從 browser 模組導入 html 類別, 主要用於建立 CANVAS 標註物件, 並插入頁面中\nfrom browser import html\n# 用於定時執行特定函式\nimport browser.timer\n# 導入亂數模組\nfrom random import random, randint\n\n# 利用 html 建立一個 CANVAS 標註物件, 與變數 canvas 對應\ncanvas = html.CANVAS(width = 600, height = 600)\n# 將 canvas 標註的 id 設為 "canvas"\ncanvas.id = "canvas"\n# 將 document 中 id 為 "snake_ex1" 的標註 \n# 設為與 sname_ex1 變數對應\nsnake_ex1_pos = doc["snake_ex1"]\n# 將 canvas 標註放入 brython_div 所在位置\n# 頁面中原本就已經放入 <div id="snake_ex1"></div> 標註\nsnake_ex1_pos <= canvas\n# 將 canvas 的 2d 繪圖 context 命名為 ctx\nctx = canvas.getContext("2d")\n\n# 建立一個 dRect() 函式\n# s default 為 1, c default 為紅色\ndef dRect(lux, luy, w, h, s=1, c=\'#ff0000\'):\n    ctx.lineWidth = s\n    ctx.strokeStyle = c\n    ctx.beginPath();\n    ctx.rect(lux, luy, w, h)\n    ctx.stroke();\n    \n# 建立畫直線函式\ndef draw_line(x1, y1, x2, y2, color="#ff0000"):\n    ctx.beginPath()\n    ctx.moveTo(x1, y1)\n    ctx.lineTo(x2, y2)\n    ctx.strokeStyle = color\n    ctx.stroke()\n\n# 建立 write Text 函式\ndef wText(x, y, t, s=14, c=\'#0000ff\'):\n    ctx.font = str(s) + "px Arial";\n    ctx.fillText(t, x, y)\n\n# 定義畫格線的函式\ndef grid(startx, starty, w, h, wnum, hnum, pixel=1, color="#ff0000"):\n    # 利用迴圈與座標增量繪圖\n    # 因為輸入 wnum 與 hnum 為格子數, 畫格線數則需加上 1\n    for i in range(wnum+1):\n        for j in range(hnum+1):\n            # 畫上下直線\n            yend = starty + h*(hnum)\n            xend = startx + w*(wnum)\n            x = startx + i*w\n            draw_line(x, starty, x, yend, color)\n            # 畫左右直線\n            y = starty + j*h\n            draw_line(startx, y, xend, y, color)\n            #wText(w/2-10, y-w/2, str(j))\n\n# 從兩個座標點求中心點座標\ndef center(lx, ly, rx, ry):\n    # lx is x coord of the left up corner\n    # rx is the x coord of th right down corner\n    x = (lx + rx)/2\n    y = (ly + ry)/2\n    return x, y\n    \n# 畫出填色方塊\ndef draw_rect(gx, gy, gw, gh, color="lime"):\n    # gx is the grid coord at x direction\n    # gy is the grid coord at y direction\n    # gw is the width of the green rect\n    # gh is the height of the green rect\n    lx = origx + (gx-1)*w\n    ly = origy + (gy-1)*h\n    rx = origx + gx*w\n    ry = origy + gy*h\n    cx, cy = center(lx, ly, rx, ry)\n    # glx is the x coord of the left corner\n    # gly is the y coord of the left corner\n    glx = cx - gw/2\n    gly = cy - gh/2\n    # 利用設定的顏色值畫出 rectangle\n    ctx.fillStyle = color\n    ctx.fillRect(glx, gly, gw, gh)\n\n# 以白色覆蓋位於 (nowx, nowy) \n# 且比目標方塊長寬各大於 1 pixel的方塊\ndef wipe():\n    draw_rect(nowx, nowy, 30+1, 30+1, color="white")\n\n# 畫出位於 (nowx, nowy) 的綠色方塊\ndef draw():\n    draw_rect(nowx, nowy, 30, 30, color="lime")\n\n# 以隨機方式在格點座標中畫出紅色方塊\ndef draw_red():\n    draw_rect(redx, redy, wrect_size, hrect_size, color="red")\n\n# 綠色方塊往紅色方塊位置移動, 抵達目標位置後停止移動\ndef walk():\n    global stepx, stepy\n    if nowx > redx:\n        stepx = -1\n        stepy = 0\n    if nowx < redx:\n        stepx = 1\n        stepy = 0\n    if nowy > redy:\n        stepx = 0\n        stepy = -1\n    if nowy < redy:\n        stepx = 0\n        stepy = 1\n    if nowx == redx and nowy == redy:\n        stepx = 0\n        stepy = 0\n\n# 每隔短暫時間即呼叫執行一次的函式\ndef game():\n    # 因 nowx, nowy, redx, redy 在函式外宣告\n    # 且在函式內改變對應值, 因此需宣告為 global\n    global nowx, nowy, redx, redy\n    # 當綠色方塊移動至紅色方塊座標後, 產生另一個紅色目標座標值\n    if nowx == redx and nowy == redy:\n        # wnum 為 width 方向的格子數\n        # hnum 為 height 方向的格子數\n        redx = randint(1, wnum)\n        redy = randint(1, hnum)\n    draw_red()\n    walk()\n    wipe()\n    nowx += stepx\n    nowy += stepy\n    draw()\n\n# 綠色方塊起點座標與 x 及 y 方向的座標增量\nnowx = 1\nnowy = 1\nstepx = 0\nstepy = 0\ngo = True\n# 設定格數\n# width 方向格子數\nwnum = 15\n# height 方向格子數\nhnum = 15\n# 紅色方塊座標起始座標位於右下角\nredx = wnum-1\nredy = hnum-1\n# 設定線寬\npixel = 1\n# 設定 w 寬度\nw = int(canvas.width/wnum) - pixel\n# 設定 h 高度\nh = int(canvas.height/hnum) - pixel\n# 設定紅色方塊寬度與高度, 分別設為格子大小的  70%\nwrect_size = int(w*0.7)\nhrect_size = int(h*0.7)\n# 設定繪圖座標點起點位置\norigx = 1\norigy = 1\n# 利用 grid 函式畫出格線\ngrid(origx, origy, w, h, wnum, hnum, pixel=1, color="black")\n\nbrowser.timer.set_interval(game, 100) \n 以上動態繪圖結果: \n \n', 'tags': '', 'url': 'cp.html'}, {'title': 'wcm', 'text': 'https://github.com/marcoagner/Flask-QRcode   \n https://github.com/Vaibhavi24/Online-Hotel-Management-System   \n 排課系統', 'tags': '', 'url': 'wcm.html'}, {'title': 'CAD', 'text': '常見的電腦輔助設計中階套件: \n AutoDesk Inventor, Solidworks, Solid Edge \n 常見的電腦輔助設計高階套件: \n PTC Creo,  Siemens NX , Dassaults CATIA \n 常見的雲端電腦輔助設計套件: \n Onshape , AutoDesk Fusion 360 \n 開源電腦輔助設計套件: \n Solvespace \n', 'tags': '', 'url': 'CAD.html'}, {'title': 'Solvespace', 'text': '要在 Windows 64 位元操作系統中編譯 Solvespace 原始碼, 可以下載  msys64_20210419_for_cad2022.7z  (3.4 GB 解開後 12.5 GB, 必須登入 @nfu OneDrive 帳號後才能下載). \n 編譯 Solvespace 原始碼 v3.1 步驟如下: \n (一) 下載  msys64_20210419 for cad2022.7z . \n \n (二) 在 start 批次檔案中增加 msys2 搜尋路徑: \n \n REM 設定 msys2 64 位元的執行路徑 set path_msys2=%cd%\\msys64_20210419\\mingw64\\bin; REM 將 %path_msys2% 加入 path 設定 path=%cd%;%path_python%;%path_git%;%path_tcc%;%path_scite%;%path_msys2%;%path%; \n \n (三) 啟動批次檔案附加 msys2 搜尋路徑後, 必須重新啟動可攜程式系統. \n \n \n (四) 接下來取得 Solvespace 原始碼並切換到 v3.1 分支: \n \n git clone --recurse-submodules https://github.com/solvespace/solvespace.git cd solvespace git checkout v3.1 mkdir build cd build cmake .. -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Release make \n \n (五) 編譯完成後, 位於 solvespace\\build\\bin 目錄中的 solvespace.exe 需要配合 msys64_20210419\\mingw64\\bin\\libwinpthread-1.dll 檔案才能執行. \n \n Reference: \n \n \n \n solvespace v3.1 原始碼, 編譯結果與 Leo Editor 專案.7z \n solvespace.exe compiled with msys2.7z \n Solvespace Development Documentation \n \n \n', 'tags': '', 'url': 'Solvespace.html'}, {'title': 'Solvespace_ex', 'text': 'Quick Start — solvespace latest documentation \xa0 \n SolveSpace - Learning Guide (farwire.net) \n SolveSpace - Tutorials \n SolveSpace - Tutorial - 2d Sketching \n', 'tags': '', 'url': 'Solvespace_ex.html'}, {'title': 'NX', 'text': '下載  NX2027.3401_lite_cad2022.7z  (1.96 GB, 登入 @nfu OneDrive 帳號後才能下載) \n Drill Press 零組件檔案', 'tags': '', 'url': 'NX.html'}, {'title': 'Onshape', 'text': '', 'tags': '', 'url': 'Onshape.html'}, {'title': 'CoppeliaSim', 'text': 'CoppeliaSim 教育版 4.3.0 rev12  下載 \xa0(134 MB, 必須登入 @nfu OneDrive 帳號後才能下載). \n 與 CoppeliaSim 配合使用的可攜程式系統: \n 2022 Fall 最終版的 Python 可攜程式系統為 \xa0 portable_python_w10_nx_robodk.7z \xa0 (1.03 GB, 必須登入 @nfu OneDrive 帳號後才能下載), 這是在課程第十週釋出的版本, 由於必須配合 NX2027 所採用的 NXOpen for Python API 程式解譯需求, 除了 Python 3.10.6 版之外, 還額外提供 Python 3.8.10 的解譯器版本, 以及 \xa0 RoboDK 5.5 \xa0 可攜系統.', 'tags': '', 'url': 'CoppeliaSim.html'}, {'title': 'Python\xa0script', 'text': '2022 Fall 最終版的 Python 可攜程式系統為 \xa0 portable_python_w10_nx_robodk.7z \xa0 (1.03 GB, 必須登入 @nfu OneDrive 帳號後才能下載), 這是在課程第十週釋出的版本, 由於必須配合 NX2027 所採用的 NXOpen for Python API 程式解譯需求, 除了 Python 3.10.6 版之外, 還額外提供 Python 3.8.10 的解譯器版本, 以及 \xa0 RoboDK 5.5 \xa0 可攜系統. \n CoppeliaSim 4.3.0 rev12 可以採 Python script 控制場景中的元件. 但必須在  C:\\CoppeliaSimEdu_4.3.0_rev12\\system\\usrset.txt  中進行設定: \n 原先 usrset.txt 172 與 173 行內容: \n defaultPython = // e.g. c:/Python38/python.exe executeUnsafe = false // recommended to keep false. \n 假設 python.exe 位於\xa0C:\\portable_python_w10_nx_robodk\\Python38 目錄下, 則為了讓 CoppeliaSim 能夠在場景中解譯 Python script, usrset.txt 的 172 與 173 行必須改為: \n defaultPython = C:/portable_python_w10_nx_robodk/Python38/python.exe executeUnsafe =\xa0true \n 假如使用 Python 3.10.6 解譯系統, 則\xa0 usrset.txt 的 172 與 173 行必須改為: \n defaultPython = \xa0 C:/portable_python_w10_nx_robodk/Python310/python.exe executeUnsafe =\xa0true \n C:\\CoppeliaSimEdu_4.3.0_rev12\\system\\usrset.txt 設定檔案修改之後, CoppeliaSim 必須重新啟動設定才會生效.', 'tags': '', 'url': 'Python\xa0script.html'}, {'title': 'Examples', 'text': '', 'tags': '', 'url': 'Examples.html'}, {'title': 'cp2022', 'text': '為何學習計算機程式需要建立個人倉儲? \n 從\xa0 Stack Overflow Developer Survey 2022 \xa0可得知, 專業的程式開發者將 Git 視為最基本的工具. 而 Git 工具的使用與個人在 Github 的倉儲相結合, 可以有效採分散式的方式管理個人或團隊所開發的程式碼.\xa0 \n 因此在學習計算機程式時, 若能同時熟悉位於 Github 中個人倉儲的維護, 將可在隨後的應用中採取與專業人士相容的處理流程與模式. \n 全球資訊網能夠提供甚麼功能或有什麼優點? \n Replit, stud.cycu.org 與 localhost 分別代表甚麼? \n https, ssh 到底提供使用者那些功能或優點? \n Brython 與 Python 有甚麼差別? \n 能夠直接在瀏覽器中以 Brython 繪製中華民國國旗, 或模擬綠色方塊在方塊格點中任意移動, 代表甚麼? \n 變數, 字串, 整數, 浮點數, 數列, Tuple, Dictionary, 函式, 重複迴圈, class, 物件導向, 資料庫, 這些名詞對您而言代表甚麼?', 'tags': '', 'url': 'cp2022.html'}, {'title': 'w17', 'text': '\n 函式定義與呼叫 \n def length(inch):\n    #sum = 0\n    #start = 1\n    #end = 100\n    \'\'\'\n    for i in range(start,end+1,1):\n        sum = sum + i\n        #print(i)\n    print("由" + str(start) + " 加到 " + str(end) + " 等於:" + str(sum))\n    \'\'\'\n    cm = inch * 2.54\n    print(cm)\n\n\'\'\'\nsumto(1,10)\nsumto(3, 100)\n\'\'\'\nlength(5) \n 列出 Python 關鍵字: \n import keyword\nprint(keyword.kwlist)\n\'\'\'\n[\'False\', \'None\', \'True\', \'and\', \'as\', \'assert\', \'async\', \'await\', \'break\', \'class\', \'continue\', \'def\', \'del\', \'elif\', \'else\', \'except\', \'finally\', \'for\', \'from\', \'global\', \'if\', \'import\', \'in\', \'is\', \'lambda\', \'nonlocal\', \'not\', \'or\', \'pass\', \'raise\', \'return\', \'try\', \'while\', \'with\', \'yield\']\n\'\'\' \n', 'tags': '', 'url': 'w17.html'}, {'title': 'canvas', 'text': ' 納入 Brython 環境  \n \n \n  啟動 Brython  \n \n \n  給定 brython_div1 division 標註  \n \n  加入啟動按鈕後的 Rect 行走程式原始碼  \n \n \n 關鍵程式碼: \n #grid(origx, origy, w, h, wnum, hnum, pixel=1, color="black")\n#draw_line(0, 0, 600, 600, color="black")\n\nctx.beginPath()\nctx.arc(100, 75, 50, 0, math.pi)\nctx.stroke()', 'tags': '', 'url': 'canvas.html'}]};